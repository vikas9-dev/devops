# Linux

## 1. üöÄ Linux: Foundation of DevOps

Linux is the bedrock upon which DevOps practices stand. If you're serious about mastering DevOps, this section is absolutely essential - it's not optional.

If you're already a seasoned Linux administrator, feel free to skim through. But if you're not, it's time to level up. This section is designed to make you efficient. You'll learn a lot in a short amount of time.

Here‚Äôs what we‚Äôll cover:

### üîç What You‚Äôll Learn

- Introduction to Linux: What it is, and why it matters in IT and DevOps.
- Basic commands: Copying files, moving directories, navigating the filesystem, etc.
- File system fundamentals: Understanding Linux directory structure, file types, and text file management.
- Permissions: File permissions, ownership, and how to modify them.
- Filters & Redirection: Powerful tools every DevOps engineer should know.
- Users and Groups: Managing access and system users.
- Superuser privileges: What is `sudo`, and how to use it responsibly.
- Package management: Working with RPM, Debian, Yum, Apt, and more.
- Services and Processes: Managing services, background processes, and system monitoring.
- Server management: Setting up web and database servers.
- Hands-on commands every DevOps engineer should be fluent in.

We‚Äôll focus on four main areas: **commands, files, software, and servers**‚Äîskills that are non-negotiable for anyone serious about IT.

### a. üåê What is Open Source, and Why Linux?

When you hear "open source," you might think ‚Äúfree software.‚Äù But open source is so much more.

Open source means the **source code is freely available** to inspect, improve, and redistribute. This model invites collaboration from thousands of contributors across the globe, often resulting in better security, innovation, and faster progress than traditional closed development.

Linux is the most prominent example of an open source success story. In 1991, **Linus Torvalds** developed a Unix-like open source kernel‚Äîthe **Linux kernel**. Since then, the world has built entire operating systems around it.

Today, Linux powers everything from desktops to data centers, smartphones to supercomputers.

### b. üß† Key Principles of Linux

To understand Linux is to understand its design philosophy:

- **Everything is a file**: Including devices like keyboards, mice, and network interfaces.
- **Small, modular programs**: Each tool does one thing well. Combine them to perform complex tasks.
- **Avoiding captive interfaces**: GUI is optional. CLI is king, especially for automation and scripting.
- **Text-based configuration**: Settings are in simple text files, not buried in menus‚Äîperfect for automation.
- **Stability and flexibility**: You can fine-tune Linux to work exactly how you want it to.

### c.üí° Why Linux for DevOps?

Here‚Äôs why Linux dominates the DevOps and server space:

- It's open source with massive community support.
- Highly customizable and lightweight.
- Easily automatable compared to Windows.
- Considered more secure (though that‚Äôs a debated topic).
- Supports a wide range of hardware and platforms.
- Powers most of the world's servers‚Äîand yes, your Android phone too.

### d. üèóÔ∏è Linux Architecture: A Simple Overview

At a high level, Linux looks like this:

1. **Hardware** ‚Äì CPU, RAM, disk, network.
2. **Linux Kernel** ‚Äì Talks to hardware, manages resources.
3. **Shell** ‚Äì CLI interface to issue commands.
4. **Tools & Utilities** ‚Äì Like `ls`, `cat`, or even GUI tools like browsers.
5. **Users** ‚Äì People like you, using the system.

### e. üéØ Popular Linux Distros: Desktop vs Server

#### Desktop Linux

If you're trying Linux on your personal machine, consider:

- **Ubuntu** ‚Äì Most popular, user-friendly.
- **Linux Mint** ‚Äì Great for beginners.
- **Fedora**, **Debian**, **openSUSE**, **Arch** ‚Äì Each with its own philosophy and strengths.

We recommend **dual-booting** your laptop and using Linux as often as possible to build comfort.

#### Server Linux

In DevOps, server distros are more relevant:

- **Red Hat Enterprise Linux (RHEL)** ‚Äì Enterprise-grade, stable, and secure (not open source).
- **CentOS / AlmaLinux / Rocky Linux** ‚Äì Open source alternatives to RHEL.
- **Ubuntu Server** ‚Äì Open source, user-friendly, and very popular in cloud environments.
- **SUSE Enterprise Linux** ‚Äì Popular in some enterprise setups.

### f. üß© RPM vs DEB: Packaging Systems

Most Linux distros fall into two major packaging families:

- **RPM-based** (Red Hat, CentOS, Fedora, Amazon Linux)

  - Packages use `.rpm` extension
  - Install with `rpm`, `yum`, or `dnf`

- **Debian-based** (Ubuntu, Debian, Kali)
  - Packages use `.deb` extension
  - Install with `dpkg`, `apt`

Example:

- Ubuntu: `sudo dpkg -i google-chrome.deb`
- Red Hat: `sudo rpm -ivh google-chrome.rpm`

Each system has its own commands and tools, so being familiar with both is a huge plus in DevOps.

### g. üìÅ Understanding Linux Directory Structure

Let‚Äôs quickly look at some important directories:

| Path                 | Purpose                                                |
| -------------------- | ------------------------------------------------------ |
| `/root`              | Home directory of the root (admin) user                |
| `/home/user`         | Home directory for a normal user                       |
| `/bin`, `/usr/bin`   | User-level executable commands (e.g., `ls`, `cat`)     |
| `/sbin`, `/usr/sbin` | Admin-level commands (e.g., `useradd`, `rpm`)          |
| `/etc`               | Configuration files (network, services, users)         |
| `/tmp`               | Temporary files, often deleted on reboot               |
| `/boot`              | Kernel and bootloader files                            |
| `/var`, `/srv`       | Variable data like logs, website files, database files |
| `/lib`, `/usr/lib`   | Libraries used by commands and software                |
| `/media`, `/mnt`     | Mount points for USB drives or CDs                     |
| `/proc`, `/sys`      | Virtual files with system and kernel info              |

---

## 2. üêß Linux Basic Commands and File System

Before we dive into Linux internals, let's start with the basics: how to work inside a Linux VM, run essential commands, and understand the Linux file system layout.

### ‚úÖ Starting the Vagrant VM

Ensure your CentOS-based Vagrant VM is ready. To check the status of all Vagrant-managed machines:

```bash
vagrant global-status
```

Navigate to the folder where your CentOS VM was created:

```bash
cd vagrant-vm/centos/
```

Start the VM with:

```bash
vagrant up
```

This boots the VM (if already created), and typically starts within a minute. To access it:

```bash
vagrant ssh
```

You're now inside the VM. Clear the screen with:

```bash
clear
```

### üß∞ Essential Linux Commands

Here are some basic commands to get started:

```bash
whoami     # Displays the current user
pwd        # Prints the working directory
ls         # Lists contents of the directory
cat /etc/os-release   # Displays OS name and version
```

You're logged in as the `vagrant` user, whose home directory is `/home/vagrant`.

### üí° Understanding the Terminal Prompt

```bash
[vagrant@localhost ~]$
```

The command prompt tells you:

- **User**: `vagrant`
- **Host**: Usually `localhost`
- **~ (tilde)**: Represents home directory
- **$**: Indicates a regular user shell

### üîê Becoming the Root User

To switch to the root user:

```bash
sudo -i
```

This updates your prompt:

```bash
[root@localhost ~]#
```

- **User**: `root`
- **~**: Now refers to `/root` (root's home directory)
- **#**: Indicates root privileges

Check with:

```bash
whoami   # root
pwd      # /root
```

### üìÇ `/` vs `/root` ‚Äî What's the Difference?

- `/` ‚Üí The **root directory**, top of the Linux filesystem hierarchy.
- `/root` ‚Üí The **home directory of the root user**.

Examples:

```bash
cd /      # Takes you to root directory
cd        # Brings you back to the user's home directory
```

Use `ls` in `/` to list all top-level directories.

### üó∫Ô∏è Linux File System Layout

```bash
[root@vbox /]# ls

afs  boot  etc   lib    media  opt   root  sbin  sys  usr      var
bin  dev   home  lib64  mnt    proc  run   srv   tmp  vagrant
```

Here‚Äôs an overview of key directories:

| Directory        | Description                                             |
| ---------------- | ------------------------------------------------------- |
| `/`              | Root of the entire filesystem                           |
| `/home`          | Home directories for regular users                      |
| `/root`          | Home directory of the root user                         |
| `/bin`           | Essential user commands (e.g. `ls`, `mv`, `pwd`)        |
| `/sbin`          | System-level commands (for root, e.g. `reboot`, `mkfs`) |
| `/etc`           | System configuration files                              |
| `/tmp`           | Temporary files (deleted after reboot)                  |
| `/boot`          | Kernel and bootloader files                             |
| `/var`, `/srv`   | Logs and server-specific data                           |
| `/proc`, `/sys`  | Dynamic system information                              |
| `/opt`           | Optional third-party software                           |
| `/media`, `/mnt` | Mount points for external or temporary filesystems      |

### üîé Exploring Common Directories

#### View Current Hostname

```bash
cat /etc/hostname
```

#### Boot Directory Contents

```bash
cd /boot
ls
```

You'll find kernel files like `vmlinuz`, `initramfs`, and the `grub` directory here.

#### Temporary Files

```bash
cd /tmp
ls
```

Use this directory only for short-term storage. It's wiped after reboot.

#### System Info in `/proc`

```bash
cd /proc
ls
cat uptime        # System uptime
free -m           # Memory usage
```

Files in `/proc` are dynamic and update in real-time based on the system state.

### üõ§Ô∏è Absolute vs Relative Paths

- **Absolute Path**: Starts from root (`/`)  
  Example: `/etc/hostname`, `/bin/ls`
- **Relative Path**: Based on current directory  
  Example: `cd ../`, `ls foldername/`

Use `cd /` anytime to go to the root directory, or `cd` alone to return to your home directory.

### üîÅ Switching Between Users and Logging Out

To become the **root user**:

```bash
sudo -i
```

Your prompt will change (`#` instead of `$`), indicating root access.

To **exit root** and return to the `vagrant` user:

```bash
exit
```

To **log out of the VM entirely**, just run `exit` again. You‚Äôll be back on your **host machine** (e.g., Windows). You can reconnect anytime with:

```bash
vagrant ssh
```

### üóÇÔ∏è Creating Directories and Files

Start in the home directory (`/home/vagrant`):

```bash
cd ~   # or simply cd
```

Create directories:

```bash
mkdir dev ops backupdir
```

Create a single file:

```bash
touch testfile.txt
```

Create multiple files using brace expansion:

```bash
touch devopsfile{1..10}.txt
```

This generates 10 files: `devopsfile1.txt` to `devopsfile10.txt`.

### üìã Copying Files and Understanding Paths

Copy a file using **relative paths**: `cp <source> <destination>`

```bash
cp devopsfile1.txt dev/
```

Now check the contents:

```bash
ls dev/
```

You can also use **absolute paths**:

```bash
cp /home/vagrant/devopsfile2.txt /home/vagrant/dev/
```

Using absolute paths helps reinforce your understanding of Linux file structure.

### üìÅ Copying Directories

Attempting to copy a directory without the right option fails:

```bash
cp dev backupdir/
# Error: omitting directory
```

To copy directories, use the `-r` (recursive) flag:

```bash
cp -r dev backupdir/
```

Now `dev` is successfully copied into `backupdir`.

### üî§ Path Shortcuts

- `cd` or `cd ~` ‚Üí takes you to your home directory
- `cd /` ‚Üí takes you to the root directory
- Use `ls` with either **relative** or **absolute paths** to list contents

Example:

```bash
ls dev/                   # Relative
ls /home/vagrant/dev      # Absolute
```

### üß± Linux Command Syntax

Most Linux commands follow this pattern:

```
command [options] [arguments]
```

Examples:

- `ls -l /tmp` ‚Üí long listing of `/tmp`
- `cp -r dev backupdir/` ‚Üí copy directory recursively

To view available options for any command:

```bash
cp --help
```

You‚Äôll see a list of flags like:

- `-a` ‚Üí archive
- `-i` ‚Üí interactive
- `-r` / `-R` / `--recursive` ‚Üí recursive copy

### ‚úÇÔ∏è Moving and Renaming Files or Directories

Move a file:

```bash
mv devopsfile3.txt ops/
```

Move a directory:

```bash
mv ops dev/
```

Rename a file:

```bash
mv testfile.txt testfile_renamed.txt
```

### ‚ú® Wildcards and Bulk Operations

To move all `.txt` files into a directory:

```bash
mkdir textdir
mv *.txt textdir/
```

Wildcard `*` matches everything in the current directory.

### üóëÔ∏è Removing Files and Directories

Delete a single file:

```bash
rm devopsfile10.txt
```

Delete a directory:

```bash
rm -r mobile/
```

Delete everything in the current directory:

‚ö†Ô∏è **Warning: Dangerous!**

```bash
rm -rf *
```

This removes **all files and folders** in the current location **without confirmation**. If run in critical system directories, data loss is permanent. There's **no recycle bin** in Linux.

### üïò View Command History

Check all previous commands:

```bash
history
```

Use this to review and repeat past commands during practice. That wraps up our session on **basic Linux commands and file system navigation**. Practice using absolute paths, directory operations, and file manipulations until they become second nature.

---

## 3. üß© Getting Started with the Vim Editor on CentOS

In this section, we‚Äôll get hands-on with the **Vim** editor ‚Äî a powerful text editor that you‚Äôll be using throughout this course to create and modify files.

> üí° If you're already comfortable with another editor like **Nano**, feel free to use that. But if you're new to Linux text editors, **Vim** is a great place to start.

### Installing Vim on CentOS

By default, **Vim** is not installed on CentOS; however, **Vi** (a simpler version) is usually available. Since Vim is an enhanced version of Vi, let‚Äôs start by installing it:

```bash
sudo yum install vim -y
```

> If you encounter any issues during installation (e.g., network errors), don‚Äôt spend too much time troubleshooting. Simply recreate your VM or switch to an **Ubuntu** VM, where Vim is pre-installed. We'll learn more about networking with Vagrant later in the course.

### Basic Vim Operations

Let‚Äôs walk through the basics of using Vim to create, edit, save, and quit files.

#### 1. Opening a File

To create or open a file, use:

```bash
vim firstfile.txt
```

The `.txt` extension is optional ‚Äî it's just for readability.

#### 2. Vim Modes

Vim has **three modes**:

- **Command Mode**: Default mode when you open a file.
- **Insert Mode**: For writing and editing content. Enter this by pressing `i`.
- **Extended Mode**: For commands like saving or quitting. Access this by pressing `Esc` followed by `:`.

#### 3. Writing and Saving

1. Press `i` to enter **Insert Mode**.
2. Type your content:
   ```
   Welcome to Linux.
   I hope you enjoy learning the command line!
   ```
3. Press `Esc` to return to **Command Mode**.
4. Enter `:w` to **save** the file.
5. To quit, use `:q`.
6. To save and quit in one go: `:wq`.

#### 4. Quitting Without Saving

If you've made changes you don't want to keep:

```bash
:q!
```

This **force quits** without saving.

### Navigating Inside Vim

Use these shortcuts for efficient navigation:

- `:set nu` ‚Äì Show line numbers
- `gg` ‚Äì Go to the beginning of the file
- `G` ‚Äì Go to the end of the file
- `w` ‚Äì Move cursor forward one word
- `5w` ‚Äì Move cursor 5 words forward
- `b` ‚Äì Move back one word
- `nb` ‚Äì Move back N words (like `5b`)

### Copy, Paste, and Delete in Vim

#### Copying (Yanking)

- `yy` ‚Äì Copy current line
- `4yy` ‚Äì Copy 4 lines from the current line
- `p` ‚Äì Paste below the cursor
- `P` ‚Äì Paste above the cursor

#### Cutting (Deleting)

- `dd` ‚Äì Delete (cut) current line
- `4dd` ‚Äì Delete (cut) 4 lines
- `u` ‚Äì Undo last change
- `U` ‚Äì Undo all changes (entire line)
- `CTRL + R` ‚Äì Redo

> Deleting in Vim is essentially a **cut** operation. You can paste it using `p` or `P`.

#### Deleting All Lines

```bash
117dd
```

(Deletes 117 lines, assuming that's your total line count)

Undo with `u` or quit without saving with `:q!`.

### Searching in Vim

To search for a word:

1. Press `/` in **Command Mode**
2. Type the word (e.g., `/network`)
3. Press `Enter`
4. Use `n` to jump to the next match

> Search is **case-sensitive** by default.

Vim is an extremely powerful tool once you‚Äôre comfortable with it. In upcoming sessions, we‚Äôll build on these fundamentals with more advanced features.

> üí™ **Pro Tip**: Practice is key. Use Vim as much as possible during this course to build muscle memory.

---

## 4. üèóÔ∏è Understanding File Types in Linux

In this section, we‚Äôll explore the different types of files in Linux. You might already know about basic file types like **text files** and **directories**, but in Linux, **everything is treated as a file**‚Äîyour keyboard, mouse, terminal sessions, and more.

Let‚Äôs dive deeper.

### File Identification with `ls -l`

```bash
ls -l /dev
```

When you run the `ls -l` command, it shows a **long listing** format. The first character in the output reveals the **file type**:

- `-` : Regular file (can be text or binary)
- `d` : Directory
- `l` : Symbolic (soft) link
- `c` : Character device file (e.g., keyboard, tty)
- `b` : Block device file (e.g., hard disks)
- `s` : Socket file (used for inter-process communication)
- `p` : Named pipe (FIFO)

The color coding in tools like Git Bash can help, but it's the first character of the `ls -l` output that truly defines the type.

### Identifying File Content with `file`

To confirm if a file is a text file, script, or binary, use the `file` command:

```bash
file filename
```

Examples:

```bash
file /bin/pwd        # Outputs: ELF 64-bit LSB executable (binary)
file yum             # Outputs: Python script or ASCII text
```

### Exploring Special Files

Check out the `/dev` directory using `ls -l /dev`. You‚Äôll see:

- **Character files (c)** ‚Äì e.g., `/dev/tty` for terminal sessions
- **Block files (b)** ‚Äì e.g., `/dev/sda` for hard disks

These are device files, used by the kernel for hardware I/O.

### Working with Symbolic Links

You can create shortcuts using symbolic (soft) links:

```bash
ln -s /path/to/original /path/to/link
```

First create the directory ` mkdir -p /opt/dev/ops/devops/test/`. Create the file `vim /opt/dev/ops/devops/test/commands.txt`.

Example of creating symbolic link:

```bash
ln -s /opt/dev/ops/devops/test/commands.txt cmds
```

This creates a `cmds` shortcut to a deeply nested file, see `file cmds`. Check file content using `cat cmds`. If the original file is deleted or moved (e.g., `mv /opt/dev/ops/devops/test/commands.txt /tmp/`), the link becomes a **dead link** (it will appear broken in `ls -l`).

To remove a link:

```bash
rm linkname
# or
unlink linkname
```

### Sorting with `ls`

The `ls` command can be enhanced with useful flags:

- `-l` : Long listing format
- `-t` : Sort by modification time
- `-r` : Reverse the sort order

Example:

```bash
ls -ltr /etc
```

This shows the contents of `/etc`, sorted by last modification time in reverse‚Äîuseful for tracking recent changes.

### Changing Hostname (Example Use Case)

To change the hostname on a CentOS system:

1. Edit the `/etc/hostname` file:
   ```bash
   vim /etc/hostname
   ```
   Update it to:
   ```
   centos.devops.in
   ```
2. Save and quit, then run:
   ```bash
   $ hostname
   ```
   It should reflect the new name.
3. Re-login to see the new hostname applied in the terminal.

### Viewing Command History

- For the current user:
  ```bash
  history
  ```
- For root:
  ```bash
  sudo -i
  history
  ```

---

## 5. Filtering and Redirection in Linux: A System Admin‚Äôs Best Friend

One of the most powerful aspects of working in Linux is the ability to **filter data** and **redirect outputs** with ease. If you're aiming to be efficient and smart in Linux, mastering these skills is essential‚Äîespecially for scripting and system administration tasks.

In this section, we'll explore a variety of **filtering commands** and **I/O redirection techniques** that are widely used in daily operations:

### a. üîç Filtering with `grep`, `cut`, and `awk`

#### a.1. üîç Filtering with `grep`

- Use the `grep` command to search for text within files. Add `-i` to ignore case sensitivity, or `-R` to search recursively through directories.
- Want to see what‚Äôs _not_ there? Use `grep -v` to exclude matches.

```bash
grep "pattern" /path/to/file
```

Example:

```bash
[root@centos ~]# ls
anaconda-ks.cfg  original-ks.cfg

[root@centos ~]# grep firewall anaconda-ks.cfg
firewall --disabled

[root@centos ~]# grep -i firewall anaconda-ks.cfg
# Firewall configuration
firewall --disabled

[root@centos ~]# grep -i firewall < anaconda-ks.cfg
# Firewall configuration
firewall --disabled
```
The `grep -i firewall anaconda-ks.cfg` command internally works as `grep -i "firewall" < anaconda-ks.cfg`. It means `anaconda-ks.cfg` file is input to the command `grep -i "firewall"`.

**Search for a text in the current directory**:-

```bash
[root@centos ~]# grep -i firewall *
anaconda-ks.cfg:# This is test firewall
anaconda-ks.cfg:# Firewall configuration
anaconda-ks.cfg:firewall --disabled
original-ks.cfg:firewall --disabled
```

**Search for a text in the current directory recursively**:-

```bash
[root@centos ~]# ls
anaconda-ks.cfg  original-ks.cfg
[root@centos ~]# mkdir devopsdir
[root@centos ~]# cp anaconda-ks.cfg devopsdir/
[root@centos ~]# ls devopsdir/
anaconda-ks.cfg

[root@centos ~]# grep -iR firewall *
anaconda-ks.cfg:# This is test firewall
anaconda-ks.cfg:# Firewall configuration
anaconda-ks.cfg:firewall --disabled
devopsdir/anaconda-ks.cfg:# This is test firewall
devopsdir/anaconda-ks.cfg:# Firewall configuration
devopsdir/anaconda-ks.cfg:firewall --disabled
original-ks.cfg:firewall --disabled
```

Example of searching for a configuration in entire `/etc` directory:-

```bash
grep -R SELINUX /etc/*
```

We can use `-v` to exclude matches. The below command show the entire file without the line containing "firewall" (case insensitive because of `-i`):-

```bash
grep -vi firewall anaconda-ks.cfg
```

#### a.2. üîç Filtering with `cut`

- Use `cut` when dealing with structured data separated by delimiters (like `:` or `,`). It's perfect for extracting specific columns from files like `/etc/passwd`.

The `/etc/passwd` file stores **user account information**. Each line represents one user, with fields separated by colons `:`.

```bash
# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
```
**Fields (in order):**
1. **Username** (`root`)
2. **Password placeholder** (`x` ‚Üí actual password is in `/etc/shadow`)
3. **User ID (UID)** (`0`)
4. **Group ID (GID)** (`0`)
5. **User info/comment** (`root`)
6. **Home directory** (`/root`)
7. **Login shell** (`/bin/bash`)

So:
- `root` is the superuser with UID 0, has `/root` as home, and uses Bash.
- `bin` is a system user with no login shell (`/sbin/nologin`).

To get the first column:-

```bash
# cut -d: -f1 /etc/passwd
root
bin
daemon
adm
lp
```
To get the 3rd column:- `cut -d: -f3 /etc/passwd`

#### a.3.üîç Filtering with `awk`

- When `cut` isn‚Äôt flexible enough, turn to `awk`. It‚Äôs a powerful tool for pattern scanning and processing, letting you apply logic and regex for complex filtering.

To get the first column:-
```bash
# awk -F':' '{print $1}' /etc/passwd
root
bin
daemon
adm
lp
```

### b. üìñ Viewing Files with `less`, `more`, `head`, and `tail`

- Use `less` for interactive reading‚Äîyou can scroll and search within the file. It might look like within Vim, but it is not. Use `/` for search, `n` and `N` for next and previous matches, and `q` to quit.

```bash
less anaconda-ks.cfg
```

- `more` is a simpler alternative but with limited navigation.
- Want to preview the start or end of a file? Use `head` and `tail`. Need real-time updates (great for logs)? Add `tail -f`.

```bash
# show first N lines of the file (default is 10)
head anaconda-ks.cfg
head -20 anaconda-ks.cfg
```

```bash
# show last N lines of the file (default is 10)
tail anaconda-ks.cfg
tail -20 anaconda-ks.cfg
```

To see the dynamic content of the file, use `tail -f` üß™. It won't quit the file, if any changes happen to the file, it will show the new content. Use `Ctrl + C` or `Ctrl + Z` to quit.

```bash
tail -20f anaconda-ks.cfg
```
Example:- Use the below command, open a new terminal and do `vagrant ssh`. It will show the recent log.
```bash
tail -f /var/log/messages
```

### c. ‚úÇÔ∏è Text Manipulation with `sed` and `vim`

- Use `vim` for in-file search and replace:
  ```
  :%s/text-to-replace/new-text/g
  ```
  Add `/g` for global replacement on all matches.
  To remove (replace with nothing):-
  ```
  :%s/text-to-remove//g
  ```
- Prefer automation? Use `sed` for batch replacements across files:
  ```bash
  sed 's/text-to-replace/new-text/g' filename.txt
  ```
  It will show the updated content (like `cat`) with replacement, but it won't modify the original file. To modify the original file, use `-i` option: `sed -i 's/text-to-replace/new-text/g' filename.txt`.
  
  To replace in all the files of the current directory:- `sed -i 's/test/test1/g' *`.
---

## 6. üîÅ Input and Output Redirection in Linux

In Linux, every command produces output, and by default, this output is sent to the **standard output device**, which is usually your **screen (monitor)**. For example, when you run a command like `uptime`, the output is displayed right on the terminal.

But what if you don‚Äôt want that output to appear on the screen? What if you'd rather save it into a file or suppress it entirely? That‚Äôs where **input/output redirection** comes in.

### Redirecting Output to a File

You can redirect the output of a command to a file using the `>` symbol. For instance:

```bash
uptime > /tmp/sysinfo.txt
```

This will save the output of the `uptime` command into the file `/tmp/sysinfo.txt`. If the file doesn‚Äôt exist, it will be created. If it already exists, it will be **overwritten**.

If you want to **append** the output instead of overwriting it, use `>>`:

```bash
ls >> /tmp/sysinfo.txt
```

This will add the output of the `ls` command to the end of the existing file without erasing previous content.

### Collecting System Information

Let‚Äôs gather some useful system information and redirect it into a file:

```bash
echo "### Date" > /tmp/sysinfo.txt
date >> /tmp/sysinfo.txt

echo "### Uptime" >> /tmp/sysinfo.txt
uptime >> /tmp/sysinfo.txt

echo "### Memory Usage" >> /tmp/sysinfo.txt
free -m >> /tmp/sysinfo.txt

echo "### Disk Usage" >> /tmp/sysinfo.txt
df -h >> /tmp/sysinfo.txt
```

Now, `/tmp/sysinfo.txt` contains nicely formatted system info that could be useful for logging or troubleshooting.

### Suppressing Output

If you want to **ignore** the output of a command completely, redirect it to `/dev/null`:

```bash
yum install vim -y > /dev/null
```

This sends the output into a **black hole**‚Äîa special file that discards anything written to it.

You can also use this trick to **clear a file‚Äôs content**:

```bash
cat /dev/null > /tmp/sysinfo.txt
```

This effectively wipes out the file by redirecting ‚Äúnothing‚Äù into it. The same can be also done using:-

```bash
> /tmp/sysinfo.txt
```

### Redirecting Errors

Sometimes, a command might throw an error. These error messages are sent to **standard error (stderr)**, not standard output. To redirect them, use `2>`:

```bash
freeeeee -m 2> /tmp/error.log
```

This command attempts to run an invalid command (`freeeeee`) and redirects the error to `/tmp/error.log`.

To redirect **both** output and error messages to the same file:

```bash
command &>> /tmp/logfile.txt
```

This is very useful in bash scripting when you want to store logs or review issues later.

### Input Redirection and Piping

Redirection isn't limited to output. You can also **pipe** the output of one command into another using the `|` (pipe) symbol.

For example, to count the number of files in a directory:

```bash
ls /etc | wc -l
```
The `wc -l /etc/passwd` command counts the number of lines in the given file.

To filter output:

```bash
free -m | grep Mem
ls /etc | grep host
tail -20 /var/log/messages | grep -i vagrant
```

To get the first 10 files in a directory: `ls -l /etc | head`
To get the last 10 files in a directory: `ls -l /etc | tail`

You can chain commands together in creative ways to process data more efficiently. This is a powerful skill in Linux scripting.

### Finding Files

To **search for a file**:

```bash
find /etc -name "host*"
```

This performs a real-time search in `/etc`. Be cautious with searching from `/` (the root) as it can slow your system down.

Alternatively, use the `locate` command for faster searches:

```bash
locate host
```

Note: If `locate` is not installed, then you need to install `yum install mlocate -y` and run `updatedb`.

The `locate` is not the real-time search therefore we have to use `updatedb`.

---

## 7. Understanding Users and Groups in Linux

In this section, we‚Äôll explore how Linux manages **users and groups**‚Äîthe fundamental elements used to control access to files, directories, and system resources.

### What Are Users and Groups?

In Linux, **everything is treated as a file**, and each file is owned by a **user** and associated with a **group**. This ownership structure helps enforce access control via permissions.

- Every user has a unique **User ID (UID)**.
- Groups have a **Group ID (GID)**.
- This information is stored in `/etc/passwd` (for user details) and `/etc/group` (for group memberships).
- Passwords are stored (in encrypted form) in `/etc/shadow`.

### Types of Users

Linux systems typically categorize users into three types:

| **Type**             | **Example**       | **User ID (UID)** | **Group ID (GID)** | **Home Dir**       | **Shell**                |
|----------------------|-------------------|--------------------|--------------------|---------------------|---------------------------|
| Root User            | `root`            | 0                  | 0                  | `/root`             | `/bin/bash`               |
| Regular User         | `vagrant`, `vks`| 1000 to 60000              | 1000 to 60000              | `/home/<username>`  | `/bin/bash` (or similar)  |
| System/Service User  | `sshd`, `ftp`, `apache`     | 1 to 999              | 1 to 999              | `/var/ftp`, etc.| `/sbin/nologin` or `/bin/false` |

1. **Root User**:- Has full administrative privileges.
2. **Regular Users**:- Used for day-to-day tasks by real people.
3. **System/Service Users**:- Often have no login shell (`/sbin/nologin` or `/bin/false`) and sometimes no home directory.

### Working with `/etc/passwd` and `/etc/group`

The `/etc/passwd` file contains information like:
- Username
- Link to encrypted password (indicated by `x`)
- UID (User ID)
- GID (Group ID)
- Comments
- Home directory
- Login shell

Example: `grep vagrant /etc/passwd`
```
vagrant:x:1000:1000:Vagrant User:/home/vagrant:/bin/bash
```

The `/etc/group` file lists group names and their members. For instance: `grep vagrant /etc/group`
```
vagrant:x:1000:
```

When creating a user, a primary group with the same name is usually created by default.

To get all the groups a user belongs to:
```bash
# id vagrant
uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant)
```

### Creating Users and Groups

You can create users with the `useradd` command:
```bash
useradd ansible
useradd jenkins
useradd aws
```

Check their entries with:
```bash
tail -4 /etc/passwd
tail -4 /etc/group
```

Create a new group:
```bash
groupadd devops
```

### Adding Users to Groups

To add users to a secondary group:
```bash
usermod -aG devops ansible
```
Here `G` represents secondary group. For primary group we can use `g`.

Alternatively, directly edit `/etc/group`:
```bash
devops:x:1010:ansible,jenkins,aws
```

Check group membership:-
```bash
[root@centos ~]# id ansible
uid=1001(ansible) gid=1001(ansible) groups=1001(ansible),1004(devops)

[root@centos ~]# grep devops /etc/group
devops:x:1004:ansible
```

### Setting and Resetting Passwords

Root user can reset any users password by using `passwd username` command, also user can reset its own password by running just `passwd` command.

Set or reset a password:

```bash
passwd ansible
passwd aws
passwd jenkins
```

Only the **root user** can reset others‚Äô passwords. Root can also switch to any user without a password using: `su - user`

```bash
[root@centos ~]# su - ansible
[ansible@centos ~]$ whoami
ansible
```

Regular users will be prompted for a password when switching:
```bash
su - aws
```

Use `exit` to logout from the current user.

### Monitoring User Activity

Useful commands:
- `who`: See who is logged in.
- `whoami`: Shows current user.
- `last`: Shows login history.
- `lsof -u username`: Lists open files by a user (install `lsof` if needed). This command is often used to find open ports, logged in users, etc.

```bash
yum install lsof -y
lsof -u aws
```

### Deleting Users and Groups

Delete a user:
```bash
userdel aws
```
But it won't delete its home directory:- `ls /home`

Delete a user and their home directory:
```bash
userdel -r jenkins
userdel -r ansible
```

Delete a group:
```bash
groupdel devops
```

To remove remaining home directories manually:
```bash
rm -rf /home/aws
```

Finally, you can view your command history with:
```bash
history
```

---

## 8. File Permissions and Ownership in Linux

In this section, we‚Äôll explore how file permissions and ownership work in Linux, along with how to manage them using both symbolic and numeric methods.

### File Types and Ownership

Every file in Linux has an owner and an associated group. When you run `ls -l`, you‚Äôll see details like this:

```bash
-rw-r--r-- 1 root root 1234 Jan 1 12:00 anaconda-ks.cfg
```

- The first character (`-`) indicates the file type (`-` for file, `d` for directory, `l` for link).
- The next 9 characters represent permissions:  
  - `rw-` for the owner  
  - `r-x` for the group  
  - `r-x` for others

This means:
- **Owner (root)**: read & write (`rw-`)
- **Group (root)**: read & execute (`r-x`)
- **Others**: read & execute (`r-x`)

### Exploring Permissions with `ls -l`

Let's inspect files in the root user‚Äôs home directory:

```bash
ls -l ~
```

You‚Äôll see a mix of files, directories, and symbolic links. For example, for `anaconda-ks.cfg`, the file is owned by the `root` user and group. Its permissions are read and write for the owner, and none for group and others.

### Understanding Permission Bits

Permissions are divided into three sets:
- **User (owner)**: the creator or assigned user
- **Group**: members of the file‚Äôs group
- **Others**: everyone else

Each permission has a symbolic and numeric representation:
- **Read (r)** = 4  
- **Write (w)** = 2  
- **Execute (x)** = 1

So:
- `rwx` = 4+2+1 = **7**
- `rw-` = 4+2 = **6**
- `r--` = 4 = **4**

### Creating and Modifying Directories with Permissions

Let‚Äôs walk through an example.

1. **Create a new directory:**

```bash
mkdir /opt/devopsdir
```

2. **Create a group and users:**

```bash
groupadd devops
useradd ansible
useradd jenkins
useradd aws
useradd miles
```

3. **Add users (except `miles`) to the group:**
Edit the `/etc/group` file or use:

```bash
usermod -aG devops ansible
usermod -aG devops jenkins
usermod -aG devops aws
```

4. **Change ownership of the directory:**

```bash
chown ansible:devops /opt/devopsdir
```

If we want to change ownership of subdirectories also then we can use `-R`: `chown -R ansible:devops /opt/devopsdir`. Be careful while doing this because it will do recursive changes to the all subdirectories and we can't undo it.

```sh
# ls -ld /opt/devopsdir/
drwxr-xr-x. 2 ansible devops 6 Apr 14 15:52 /opt/devopsdir/

```

5. **Modify permissions:**
   - Add execute permission to the owner (`u`):
     ```bash
     chmod u+x /opt/devopsdir
     ```
   - Remove all permissions for others (`o`):
     ```bash
     chmod o-rx /opt/devopsdir
     ```
   - Add write permission to the group (`g`):
     ```bash
     chmod g+w /opt/devopsdir
     ```
   - Give execute permission to all users:
     ```bash
     chmod +x /opt/devopsdir
     ```

```bash
# ls -ld /opt/devopsdir/
drwxrwx---. 2 ansible devops 6 Apr 14 15:52 /opt/devopsdir/
```

Now:
- **User `ansible`** has full access.
- **Group `devops`** also has full access (can read, write, and execute).
- **Others** have no access at all.

### Testing Permissions

Switch to a user **not** in the `devops` group (like `miles`) and try:

```bash
su - miles
ls /opt/devopsdir       # Permission denied
cd /opt/devopsdir       # Permission denied
touch /opt/devopsdir/test.txt  # Permission denied
```

Switch to a user **in** the group (like `aws`) and try:

```bash
su - aws
cd /opt/devopsdir
touch awsfiles.txt      # File will be created successfully
```

### Using the Numeric Method (`chmod 770`)

Instead of using symbolic flags (`rwx`), you can assign permissions using numbers.

**Example:**
```bash
chmod 770 /opt/devopsdir
```

Breakdown:
- 7 (Owner): read (4) + write (2) + execute (1)
- 7 (Group): read (4) + write (2) + execute (1)
- 0 (Others): no permissions

**Another example:**
```bash
chmod 754 /opt/devopsdir
```

- 7: rwx (Owner)
- 5: r-x (Group)
- 4: r-- (Others)

This numeric method is quicker and often preferred in scripts or automated tasks.

Note:-
- `chown` command is to change ownership of the file.
- `chmod` is to change mode of a file.

---

## 9. Managing `sudo` Access in Linux Systems

In this section, we‚Äôll explore how the `sudo` command works in Linux and how to configure user access to execute privileged operations.

The `sudo` command allows a regular user to execute commands with root (administrator) privileges. It's commonly used to perform system-level tasks without logging in as the root user. For example, `sudo -i` opens a root shell, and `sudo yum install git` installs software packages with elevated permissions.

### Default Behavior of `sudo`

By default, only users listed in the `sudoers` file (usually members of the `sudo` or `wheel` group, depending on the distribution) can execute commands using `sudo`. If a user without proper permissions attempts to use `sudo`, they will receive an error message indicating they are not in the `sudoers` file.

### Granting `sudo` Access to a User

To allow a user to run commands with `sudo`, their privileges must be defined in the `/etc/sudoers` file or a configuration file under the `/etc/sudoers.d/` directory. It's important **not** to edit `/etc/sudoers` directly using regular text editors, as a syntax error can break access to administrative tasks.

Instead, always use the `visudo` command to safely edit the sudoers configuration:

```bash
sudo visudo
```

This command opens the `/etc/sudoers` file in a safe mode that performs syntax checking before saving changes. To grant a specific user full sudo access, add a line like the following:

```bash
username ALL=(ALL) ALL
```

If you want the user to be able to execute sudo commands **without being prompted for their password**, modify the entry as:

```bash
username ALL=(ALL) NOPASSWD: ALL
```

Example:-
```bash
[vagrant@centos ~]$ sudo -i

[root@centos ~]# passwd ansible
Changing password for user ansible.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.

[root@centos ~]# su - ansible
```
```bash
[ansible@centos ~]$ sudo useradd test12

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for ansible:
ansible is not in the sudoers file.  This incident will be reported.
```
```bash
[ansible@centos ~]$ sudo -i
[sudo] password for ansible:
ansible is not in the sudoers file.  This incident will be reported.

[ansible@centos ~]$ exit
```
Let us give the `ansible` user sudo access.
```bash
[root@centos ~]# ls -l /etc/sudoers
-r--r-----. 1 root root 4328 Jan 24  2024 /etc/sudoers

[root@centos ~]# visudo
```
In the line below from `root    ALL=(ALL)       ALL` add the line:- `ansible ALL=(ALL)       ALL`. Then save the file and exit using the command `:wq`. Now the `ansible` user can execute sudo commands.
```bash
[ansible@centos ~]$ sudo -i
[sudo] password for ansible:
```
To access the root user without password, we need to update the added line to the line `ansible ALL=(ALL) NOPASSWD: ALL` in the sudoers file.
```bash
[root@centos ~]# sudo visudo
[root@centos ~]# su - ansible
# login without password
[ansible@centos ~]$ sudo useradd test12
[ansible@centos ~]$ exit
```
In the `/etc/sudoers.d/` directory:-
```bash
[root@centos ~]# cd /etc/sudoers.d/
[root@centos sudoers.d]# ls
vagrant
[root@centos sudoers.d]# cat vagrant
%vagrant ALL=(ALL) NOPASSWD: ALL

[root@centos sudoers.d]# cp vagrant devops
[root@centos sudoers.d]# vim devops
```
In the file, add the following line:-
```bash
%devops ALL=(ALL) NOPASSWD: ALL
```

### Using the `/etc/sudoers.d/` Directory

A safer and more modular approach is to create a custom configuration file inside the `/etc/sudoers.d/` directory. This avoids modifying the main sudoers file and makes managing permissions easier.

For example, to grant sudo privileges to all users in a group named `devops`, create a file like this:

```bash
sudo visudo -f /etc/sudoers.d/devops
```

Then add the following line:

```bash
%devops ALL=(ALL) NOPASSWD: ALL
```

The `%` prefix indicates that this is a group, not a user.

### Handling Errors in `sudoers`

If a syntax error is introduced into the sudoers configuration, `visudo` will detect it upon saving and prompt you to correct it. If you attempt to edit the sudoers file without using `visudo` and introduce an error, you may lose sudo access entirely ‚Äî a serious issue if you don't have the root password.

### Summary

- `sudo` allows non-root users to execute commands with elevated privileges.
- Use `visudo` to safely edit the sudoers configuration.
- Add entries either directly in `/etc/sudoers` or create custom files in `/etc/sudoers.d/`.
- Avoid syntax errors ‚Äî always validate changes using `visudo`.
- Use the `NOPASSWD` directive for automation or non-interactive use cases.

---

## 10.

---

## 11.

---

## 12.

---

## 13.

---

## 14.

---

## 15.

---