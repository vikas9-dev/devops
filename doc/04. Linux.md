# Linux

## 1. üöÄ Linux: Foundation of DevOps

Linux is the bedrock upon which DevOps practices stand. If you're serious about mastering DevOps, this section is absolutely essential - it's not optional.

If you're already a seasoned Linux administrator, feel free to skim through. But if you're not, it's time to level up. This section is designed to make you efficient. You'll learn a lot in a short amount of time.

Here‚Äôs what we‚Äôll cover:

### üîç What You‚Äôll Learn

- Introduction to Linux: What it is, and why it matters in IT and DevOps.
- Basic commands: Copying files, moving directories, navigating the filesystem, etc.
- File system fundamentals: Understanding Linux directory structure, file types, and text file management.
- Permissions: File permissions, ownership, and how to modify them.
- Filters & Redirection: Powerful tools every DevOps engineer should know.
- Users and Groups: Managing access and system users.
- Superuser privileges: What is `sudo`, and how to use it responsibly.
- Package management: Working with RPM, Debian, Yum, Apt, and more.
- Services and Processes: Managing services, background processes, and system monitoring.
- Server management: Setting up web and database servers.
- Hands-on commands every DevOps engineer should be fluent in.

We‚Äôll focus on four main areas: **commands, files, software, and servers**‚Äîskills that are non-negotiable for anyone serious about IT.

### a. üåê What is Open Source, and Why Linux?

When you hear "open source," you might think ‚Äúfree software.‚Äù But open source is so much more.

Open source means the **source code is freely available** to inspect, improve, and redistribute. This model invites collaboration from thousands of contributors across the globe, often resulting in better security, innovation, and faster progress than traditional closed development.

Linux is the most prominent example of an open source success story. In 1991, **Linus Torvalds** developed a Unix-like open source kernel‚Äîthe **Linux kernel**. Since then, the world has built entire operating systems around it.

Today, Linux powers everything from desktops to data centers, smartphones to supercomputers.

### b. üß† Key Principles of Linux

To understand Linux is to understand its design philosophy:

- **Everything is a file**: Including devices like keyboards, mice, and network interfaces.
- **Small, modular programs**: Each tool does one thing well. Combine them to perform complex tasks.
- **Avoiding captive interfaces**: GUI is optional. CLI is king, especially for automation and scripting.
- **Text-based configuration**: Settings are in simple text files, not buried in menus‚Äîperfect for automation.
- **Stability and flexibility**: You can fine-tune Linux to work exactly how you want it to.

### c.üí° Why Linux for DevOps?

Here‚Äôs why Linux dominates the DevOps and server space:

- It's open source with massive community support.
- Highly customizable and lightweight.
- Easily automatable compared to Windows.
- Considered more secure (though that‚Äôs a debated topic).
- Supports a wide range of hardware and platforms.
- Powers most of the world's servers‚Äîand yes, your Android phone too.

### d. üèóÔ∏è Linux Architecture: A Simple Overview

At a high level, Linux looks like this:

1. **Hardware** ‚Äì CPU, RAM, disk, network.
2. **Linux Kernel** ‚Äì Talks to hardware, manages resources.
3. **Shell** ‚Äì CLI interface to issue commands.
4. **Tools & Utilities** ‚Äì Like `ls`, `cat`, or even GUI tools like browsers.
5. **Users** ‚Äì People like you, using the system.

### e. üéØ Popular Linux Distros: Desktop vs Server

#### Desktop Linux

If you're trying Linux on your personal machine, consider:

- **Ubuntu** ‚Äì Most popular, user-friendly.
- **Linux Mint** ‚Äì Great for beginners.
- **Fedora**, **Debian**, **openSUSE**, **Arch** ‚Äì Each with its own philosophy and strengths.

We recommend **dual-booting** your laptop and using Linux as often as possible to build comfort.

#### Server Linux

In DevOps, server distros are more relevant:

- **Red Hat Enterprise Linux (RHEL)** ‚Äì Enterprise-grade, stable, and secure (not open source).
- **CentOS / AlmaLinux / Rocky Linux** ‚Äì Open source alternatives to RHEL.
- **Ubuntu Server** ‚Äì Open source, user-friendly, and very popular in cloud environments.
- **SUSE Enterprise Linux** ‚Äì Popular in some enterprise setups.

### f. üß© RPM vs DEB: Packaging Systems

Most Linux distros fall into two major packaging families:

- **RPM-based** (Red Hat, CentOS, Fedora, Amazon Linux)

  - Packages use `.rpm` extension
  - Install with `rpm`, `yum`, or `dnf`

- **Debian-based** (Ubuntu, Debian, Kali)
  - Packages use `.deb` extension
  - Install with `dpkg`, `apt`

Example:

- Ubuntu: `sudo dpkg -i google-chrome.deb`
- Red Hat: `sudo rpm -ivh google-chrome.rpm`

Each system has its own commands and tools, so being familiar with both is a huge plus in DevOps.

### g. üìÅ Understanding Linux Directory Structure

Let‚Äôs quickly look at some important directories:

| Path                 | Purpose                                                |
| -------------------- | ------------------------------------------------------ |
| `/root`              | Home directory of the root (admin) user                |
| `/home/user`         | Home directory for a normal user                       |
| `/bin`, `/usr/bin`   | User-level executable commands (e.g., `ls`, `cat`)     |
| `/sbin`, `/usr/sbin` | Admin-level commands (e.g., `useradd`, `rpm`)          |
| `/etc`               | Configuration files (network, services, users)         |
| `/tmp`               | Temporary files, often deleted on reboot               |
| `/boot`              | Kernel and bootloader files                            |
| `/var`, `/srv`       | Variable data like logs, website files, database files |
| `/lib`, `/usr/lib`   | Libraries used by commands and software                |
| `/media`, `/mnt`     | Mount points for USB drives or CDs                     |
| `/proc`, `/sys`      | Virtual files with system and kernel info              |

---

## 2. üêß Linux Basic Commands and File System

Before we dive into Linux internals, let's start with the basics: how to work inside a Linux VM, run essential commands, and understand the Linux file system layout.

### ‚úÖ Starting the Vagrant VM

Ensure your CentOS-based Vagrant VM is ready. To check the status of all Vagrant-managed machines:

```bash
vagrant global-status
```

Navigate to the folder where your CentOS VM was created:

```bash
cd vagrant-vm/centos/
```

Start the VM with:

```bash
vagrant up
```

This boots the VM (if already created), and typically starts within a minute. To access it:

```bash
vagrant ssh
```

You're now inside the VM. Clear the screen with:

```bash
clear
```

### üß∞ Essential Linux Commands

Here are some basic commands to get started:

```bash
whoami     # Displays the current user
pwd        # Prints the working directory
ls         # Lists contents of the directory
cat /etc/os-release   # Displays OS name and version
```

You're logged in as the `vagrant` user, whose home directory is `/home/vagrant`.

### üí° Understanding the Terminal Prompt

```bash
[vagrant@localhost ~]$
```

The command prompt tells you:

- **User**: `vagrant`
- **Host**: Usually `localhost`
- **~ (tilde)**: Represents home directory
- **$**: Indicates a regular user shell

### üîê Becoming the Root User

To switch to the root user:

```bash
sudo -i
```

This updates your prompt:

```bash
[root@localhost ~]#
```

- **User**: `root`
- **~**: Now refers to `/root` (root's home directory)
- **#**: Indicates root privileges

Check with:

```bash
whoami   # root
pwd      # /root
```

### üìÇ `/` vs `/root` ‚Äî What's the Difference?

- `/` ‚Üí The **root directory**, top of the Linux filesystem hierarchy.
- `/root` ‚Üí The **home directory of the root user**.

Examples:

```bash
cd /      # Takes you to root directory
cd        # Brings you back to the user's home directory
```

Use `ls` in `/` to list all top-level directories.

### üó∫Ô∏è Linux File System Layout

```bash
[root@vbox /]# ls

afs  boot  etc   lib    media  opt   root  sbin  sys  usr      var
bin  dev   home  lib64  mnt    proc  run   srv   tmp  vagrant
```

Here‚Äôs an overview of key directories:

| Directory        | Description                                             |
| ---------------- | ------------------------------------------------------- |
| `/`              | Root of the entire filesystem                           |
| `/home`          | Home directories for regular users                      |
| `/root`          | Home directory of the root user                         |
| `/bin`           | Essential user commands (e.g. `ls`, `mv`, `pwd`)        |
| `/sbin`          | System-level commands (for root, e.g. `reboot`, `mkfs`) |
| `/etc`           | System configuration files                              |
| `/tmp`           | Temporary files (deleted after reboot)                  |
| `/boot`          | Kernel and bootloader files                             |
| `/var`, `/srv`   | Logs and server-specific data                           |
| `/proc`, `/sys`  | Dynamic system information                              |
| `/opt`           | Optional third-party software                           |
| `/media`, `/mnt` | Mount points for external or temporary filesystems      |

### üîé Exploring Common Directories

#### View Current Hostname

```bash
cat /etc/hostname
```

#### Boot Directory Contents

```bash
cd /boot
ls
```

You'll find kernel files like `vmlinuz`, `initramfs`, and the `grub` directory here.

#### Temporary Files

```bash
cd /tmp
ls
```

Use this directory only for short-term storage. It's wiped after reboot.

#### System Info in `/proc`

```bash
cd /proc
ls
cat uptime        # System uptime
free -m           # Memory usage
```

Files in `/proc` are dynamic and update in real-time based on the system state.

### üõ§Ô∏è Absolute vs Relative Paths

- **Absolute Path**: Starts from root (`/`)  
  Example: `/etc/hostname`, `/bin/ls`
- **Relative Path**: Based on current directory  
  Example: `cd ../`, `ls foldername/`

Use `cd /` anytime to go to the root directory, or `cd` alone to return to your home directory.

### üîÅ Switching Between Users and Logging Out

To become the **root user**:

```bash
sudo -i
```

Your prompt will change (`#` instead of `$`), indicating root access.

To **exit root** and return to the `vagrant` user:

```bash
exit
```

To **log out of the VM entirely**, just run `exit` again. You‚Äôll be back on your **host machine** (e.g., Windows). You can reconnect anytime with:

```bash
vagrant ssh
```

### üóÇÔ∏è Creating Directories and Files

Start in the home directory (`/home/vagrant`):

```bash
cd ~   # or simply cd
```

Create directories:

```bash
mkdir dev ops backupdir
```

Create a single file:

```bash
touch testfile.txt
```

Create multiple files using brace expansion:

```bash
touch devopsfile{1..10}.txt
```

This generates 10 files: `devopsfile1.txt` to `devopsfile10.txt`.

### üìã Copying Files and Understanding Paths

Copy a file using **relative paths**: `cp <source> <destination>`

```bash
cp devopsfile1.txt dev/
```

Now check the contents:

```bash
ls dev/
```

You can also use **absolute paths**:

```bash
cp /home/vagrant/devopsfile2.txt /home/vagrant/dev/
```

Using absolute paths helps reinforce your understanding of Linux file structure.

### üìÅ Copying Directories

Attempting to copy a directory without the right option fails:

```bash
cp dev backupdir/
# Error: omitting directory
```

To copy directories, use the `-r` (recursive) flag:

```bash
cp -r dev backupdir/
```

Now `dev` is successfully copied into `backupdir`.

### üî§ Path Shortcuts

- `cd` or `cd ~` ‚Üí takes you to your home directory
- `cd /` ‚Üí takes you to the root directory
- Use `ls` with either **relative** or **absolute paths** to list contents

Example:

```bash
ls dev/                   # Relative
ls /home/vagrant/dev      # Absolute
```

### üß± Linux Command Syntax

Most Linux commands follow this pattern:

```
command [options] [arguments]
```

Examples:

- `ls -l /tmp` ‚Üí long listing of `/tmp`
- `cp -r dev backupdir/` ‚Üí copy directory recursively

To view available options for any command:

```bash
cp --help
```

You‚Äôll see a list of flags like:

- `-a` ‚Üí archive
- `-i` ‚Üí interactive
- `-r` / `-R` / `--recursive` ‚Üí recursive copy

### ‚úÇÔ∏è Moving and Renaming Files or Directories

Move a file:

```bash
mv devopsfile3.txt ops/
```

Move a directory:

```bash
mv ops dev/
```

Rename a file:

```bash
mv testfile.txt testfile_renamed.txt
```

### ‚ú® Wildcards and Bulk Operations

To move all `.txt` files into a directory:

```bash
mkdir textdir
mv *.txt textdir/
```

Wildcard `*` matches everything in the current directory.

### üóëÔ∏è Removing Files and Directories

Delete a single file:

```bash
rm devopsfile10.txt
```

Delete a directory:

```bash
rm -r mobile/
```

Delete everything in the current directory:

‚ö†Ô∏è **Warning: Dangerous!**

```bash
rm -rf *
```

This removes **all files and folders** in the current location **without confirmation**. If run in critical system directories, data loss is permanent. There's **no recycle bin** in Linux.

### üïò View Command History

Check all previous commands:

```bash
history
```

Use this to review and repeat past commands during practice. That wraps up our session on **basic Linux commands and file system navigation**. Practice using absolute paths, directory operations, and file manipulations until they become second nature.

---

## 3. üß© Getting Started with the Vim Editor on CentOS

In this section, we‚Äôll get hands-on with the **Vim** editor ‚Äî a powerful text editor that you‚Äôll be using throughout this course to create and modify files.

> üí° If you're already comfortable with another editor like **Nano**, feel free to use that. But if you're new to Linux text editors, **Vim** is a great place to start.

### Installing Vim on CentOS

By default, **Vim** is not installed on CentOS; however, **Vi** (a simpler version) is usually available. Since Vim is an enhanced version of Vi, let‚Äôs start by installing it:

```bash
sudo yum install vim -y
```

> If you encounter any issues during installation (e.g., network errors), don‚Äôt spend too much time troubleshooting. Simply recreate your VM or switch to an **Ubuntu** VM, where Vim is pre-installed. We'll learn more about networking with Vagrant later in the course.

### Basic Vim Operations

Let‚Äôs walk through the basics of using Vim to create, edit, save, and quit files.

#### 1. Opening a File

To create or open a file, use:

```bash
vim firstfile.txt
```

The `.txt` extension is optional ‚Äî it's just for readability.

#### 2. Vim Modes

Vim has **three modes**:

- **Command Mode**: Default mode when you open a file.
- **Insert Mode**: For writing and editing content. Enter this by pressing `i`.
- **Extended Mode**: For commands like saving or quitting. Access this by pressing `Esc` followed by `:`.

#### 3. Writing and Saving

1. Press `i` to enter **Insert Mode**.
2. Type your content:
   ```
   Welcome to Linux.
   I hope you enjoy learning the command line!
   ```
3. Press `Esc` to return to **Command Mode**.
4. Enter `:w` to **save** the file.
5. To quit, use `:q`.
6. To save and quit in one go: `:wq`.

#### 4. Quitting Without Saving

If you've made changes you don't want to keep:

```bash
:q!
```

This **force quits** without saving.

### Navigating Inside Vim

Use these shortcuts for efficient navigation:

- `:set nu` ‚Äì Show line numbers
- `gg` ‚Äì Go to the beginning of the file
- `G` ‚Äì Go to the end of the file
- `w` ‚Äì Move cursor forward one word
- `5w` ‚Äì Move cursor 5 words forward
- `b` ‚Äì Move back one word
- `nb` ‚Äì Move back N words (like `5b`)

### Copy, Paste, and Delete in Vim

#### Copying (Yanking)

- `yy` ‚Äì Copy current line
- `4yy` ‚Äì Copy 4 lines from the current line
- `p` ‚Äì Paste below the cursor
- `P` ‚Äì Paste above the cursor

#### Cutting (Deleting)

- `dd` ‚Äì Delete (cut) current line
- `4dd` ‚Äì Delete (cut) 4 lines
- `u` ‚Äì Undo last change
- `U` ‚Äì Undo all changes (entire line)
- `CTRL + R` ‚Äì Redo

> Deleting in Vim is essentially a **cut** operation. You can paste it using `p` or `P`.

#### Deleting All Lines

```bash
117dd
```

(Deletes 117 lines, assuming that's your total line count)

Undo with `u` or quit without saving with `:q!`.

### Searching in Vim

To search for a word:

1. Press `/` in **Command Mode**
2. Type the word (e.g., `/network`)
3. Press `Enter`
4. Use `n` to jump to the next match

> Search is **case-sensitive** by default.

Vim is an extremely powerful tool once you‚Äôre comfortable with it. In upcoming sessions, we‚Äôll build on these fundamentals with more advanced features.

> üí™ **Pro Tip**: Practice is key. Use Vim as much as possible during this course to build muscle memory.

---

## 4. üèóÔ∏è Understanding File Types in Linux

In this section, we‚Äôll explore the different types of files in Linux. You might already know about basic file types like **text files** and **directories**, but in Linux, **everything is treated as a file**‚Äîyour keyboard, mouse, terminal sessions, and more.

Let‚Äôs dive deeper.

### File Identification with `ls -l`

```bash
ls -l /dev
```

When you run the `ls -l` command, it shows a **long listing** format. The first character in the output reveals the **file type**:

- `-` : Regular file (can be text or binary)
- `d` : Directory
- `l` : Symbolic (soft) link
- `c` : Character device file (e.g., keyboard, tty)
- `b` : Block device file (e.g., hard disks)
- `s` : Socket file (used for inter-process communication)
- `p` : Named pipe (FIFO)

The color coding in tools like Git Bash can help, but it's the first character of the `ls -l` output that truly defines the type.

### Identifying File Content with `file`

To confirm if a file is a text file, script, or binary, use the `file` command:

```bash
file filename
```

Examples:

```bash
file /bin/pwd        # Outputs: ELF 64-bit LSB executable (binary)
file yum             # Outputs: Python script or ASCII text
```

### Exploring Special Files

Check out the `/dev` directory using `ls -l /dev`. You‚Äôll see:

- **Character files (c)** ‚Äì e.g., `/dev/tty` for terminal sessions
- **Block files (b)** ‚Äì e.g., `/dev/sda` for hard disks

These are device files, used by the kernel for hardware I/O.

### Working with Symbolic Links

You can create shortcuts using symbolic (soft) links:

```bash
ln -s /path/to/original /path/to/link
```

First create the directory ` mkdir -p /opt/dev/ops/devops/test/`. Create the file `vim /opt/dev/ops/devops/test/commands.txt`.

Example of creating symbolic link:

```bash
ln -s /opt/dev/ops/devops/test/commands.txt cmds
```

This creates a `cmds` shortcut to a deeply nested file, see `file cmds`. Check file content using `cat cmds`. If the original file is deleted or moved (e.g., `mv /opt/dev/ops/devops/test/commands.txt /tmp/`), the link becomes a **dead link** (it will appear broken in `ls -l`).

To remove a link:

```bash
rm linkname
# or
unlink linkname
```

### Sorting with `ls`

The `ls` command can be enhanced with useful flags:

- `-l` : Long listing format
- `-t` : Sort by modification time
- `-r` : Reverse the sort order

Example:

```bash
ls -ltr /etc
```

This shows the contents of `/etc`, sorted by last modification time in reverse‚Äîuseful for tracking recent changes.

### Changing Hostname (Example Use Case)

To change the hostname on a CentOS system:

1. Edit the `/etc/hostname` file:
   ```bash
   vim /etc/hostname
   ```
   Update it to:
   ```
   centos.devops.in
   ```
2. Save and quit, then run:
   ```bash
   $ hostname
   ```
   It should reflect the new name.
3. Re-login to see the new hostname applied in the terminal.

### Viewing Command History

- For the current user:
  ```bash
  history
  ```
- For root:
  ```bash
  sudo -i
  history
  ```

---

## 5. Filtering and Redirection in Linux: A System Admin‚Äôs Best Friend

One of the most powerful aspects of working in Linux is the ability to **filter data** and **redirect outputs** with ease. If you're aiming to be efficient and smart in Linux, mastering these skills is essential‚Äîespecially for scripting and system administration tasks.

In this section, we'll explore a variety of **filtering commands** and **I/O redirection techniques** that are widely used in daily operations:

### a. üîç Filtering with `grep`, `cut`, and `awk`

#### a.1. üîç Filtering with `grep`

- Use the `grep` command to search for text within files. Add `-i` to ignore case sensitivity, or `-R` to search recursively through directories.
- Want to see what‚Äôs _not_ there? Use `grep -v` to exclude matches.

```bash
grep "pattern" /path/to/file
```

Example:

```bash
[root@centos ~]# ls
anaconda-ks.cfg  original-ks.cfg

[root@centos ~]# grep firewall anaconda-ks.cfg
firewall --disabled

[root@centos ~]# grep -i firewall anaconda-ks.cfg
# Firewall configuration
firewall --disabled

[root@centos ~]# grep -i firewall < anaconda-ks.cfg
# Firewall configuration
firewall --disabled
```
The `grep -i firewall anaconda-ks.cfg` command internally works as `grep -i "firewall" < anaconda-ks.cfg`. It means `anaconda-ks.cfg` file is input to the command `grep -i "firewall"`.

**Search for a text in the current directory**:-

```bash
[root@centos ~]# grep -i firewall *
anaconda-ks.cfg:# This is test firewall
anaconda-ks.cfg:# Firewall configuration
anaconda-ks.cfg:firewall --disabled
original-ks.cfg:firewall --disabled
```

**Search for a text in the current directory recursively**:-

```bash
[root@centos ~]# ls
anaconda-ks.cfg  original-ks.cfg
[root@centos ~]# mkdir devopsdir
[root@centos ~]# cp anaconda-ks.cfg devopsdir/
[root@centos ~]# ls devopsdir/
anaconda-ks.cfg

[root@centos ~]# grep -iR firewall *
anaconda-ks.cfg:# This is test firewall
anaconda-ks.cfg:# Firewall configuration
anaconda-ks.cfg:firewall --disabled
devopsdir/anaconda-ks.cfg:# This is test firewall
devopsdir/anaconda-ks.cfg:# Firewall configuration
devopsdir/anaconda-ks.cfg:firewall --disabled
original-ks.cfg:firewall --disabled
```

Example of searching for a configuration in entire `/etc` directory:-

```bash
grep -R SELINUX /etc/*
```

We can use `-v` to exclude matches. The below command show the entire file without the line containing "firewall" (case insensitive because of `-i`):-

```bash
grep -vi firewall anaconda-ks.cfg
```

#### a.2. üîç Filtering with `cut`

- Use `cut` when dealing with structured data separated by delimiters (like `:` or `,`). It's perfect for extracting specific columns from files like `/etc/passwd`.

The `/etc/passwd` file stores **user account information**. Each line represents one user, with fields separated by colons `:`.

```bash
# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
```
**Fields (in order):**
1. **Username** (`root`)
2. **Password placeholder** (`x` ‚Üí actual password is in `/etc/shadow`)
3. **User ID (UID)** (`0`)
4. **Group ID (GID)** (`0`)
5. **User info/comment** (`root`)
6. **Home directory** (`/root`)
7. **Login shell** (`/bin/bash`)

So:
- `root` is the superuser with UID 0, has `/root` as home, and uses Bash.
- `bin` is a system user with no login shell (`/sbin/nologin`).

To get the first column:-

```bash
# cut -d: -f1 /etc/passwd
root
bin
daemon
adm
lp
```
To get the 3rd column:- `cut -d: -f3 /etc/passwd`

#### a.3.üîç Filtering with `awk`

- When `cut` isn‚Äôt flexible enough, turn to `awk`. It‚Äôs a powerful tool for pattern scanning and processing, letting you apply logic and regex for complex filtering.

To get the first column:-
```bash
# awk -F':' '{print $1}' /etc/passwd
root
bin
daemon
adm
lp
```

### b. üìñ Viewing Files with `less`, `more`, `head`, and `tail`

- Use `less` for interactive reading‚Äîyou can scroll and search within the file. It might look like within Vim, but it is not. Use `/` for search, `n` and `N` for next and previous matches, and `q` to quit.

```bash
less anaconda-ks.cfg
```

- `more` is a simpler alternative but with limited navigation.
- Want to preview the start or end of a file? Use `head` and `tail`. Need real-time updates (great for logs)? Add `tail -f`.

```bash
# show first N lines of the file (default is 10)
head anaconda-ks.cfg
head -20 anaconda-ks.cfg
```

```bash
# show last N lines of the file (default is 10)
tail anaconda-ks.cfg
tail -20 anaconda-ks.cfg
```

To see the dynamic content of the file, use `tail -f` üß™. It won't quit the file, if any changes happen to the file, it will show the new content. Use `Ctrl + C` or `Ctrl + Z` to quit.

```bash
tail -20f anaconda-ks.cfg
```
Example:- Use the below command, open a new terminal and do `vagrant ssh`. It will show the recent log.
```bash
tail -f /var/log/messages
```

### c. ‚úÇÔ∏è Text Manipulation with `sed` and `vim`

- Use `vim` for in-file search and replace:
  ```
  :%s/text-to-replace/new-text/g
  ```
  Add `/g` for global replacement on all matches.
  To remove (replace with nothing):-
  ```
  :%s/text-to-remove//g
  ```
- Prefer automation? Use `sed` for batch replacements across files:
  ```bash
  sed 's/text-to-replace/new-text/g' filename.txt
  ```
  It will show the updated content (like `cat`) with replacement, but it won't modify the original file. To modify the original file, use `-i` option: `sed -i 's/text-to-replace/new-text/g' filename.txt`.
  
  To replace in all the files of the current directory:- `sed -i 's/test/test1/g' *`.
---

## 6. üîÅ Input and Output Redirection in Linux

In Linux, every command produces output, and by default, this output is sent to the **standard output device**, which is usually your **screen (monitor)**. For example, when you run a command like `uptime`, the output is displayed right on the terminal.

But what if you don‚Äôt want that output to appear on the screen? What if you'd rather save it into a file or suppress it entirely? That‚Äôs where **input/output redirection** comes in.

### Redirecting Output to a File

You can redirect the output of a command to a file using the `>` symbol. For instance:

```bash
uptime > /tmp/sysinfo.txt
```

This will save the output of the `uptime` command into the file `/tmp/sysinfo.txt`. If the file doesn‚Äôt exist, it will be created. If it already exists, it will be **overwritten**.

If you want to **append** the output instead of overwriting it, use `>>`:

```bash
ls >> /tmp/sysinfo.txt
```

This will add the output of the `ls` command to the end of the existing file without erasing previous content.

### Collecting System Information

Let‚Äôs gather some useful system information and redirect it into a file:

```bash
echo "### Date" > /tmp/sysinfo.txt
date >> /tmp/sysinfo.txt

echo "### Uptime" >> /tmp/sysinfo.txt
uptime >> /tmp/sysinfo.txt

echo "### Memory Usage" >> /tmp/sysinfo.txt
free -m >> /tmp/sysinfo.txt

echo "### Disk Usage" >> /tmp/sysinfo.txt
df -h >> /tmp/sysinfo.txt
```

Now, `/tmp/sysinfo.txt` contains nicely formatted system info that could be useful for logging or troubleshooting.

### Suppressing Output

If you want to **ignore** the output of a command completely, redirect it to `/dev/null`:

```bash
yum install vim -y > /dev/null
```

This sends the output into a **black hole**‚Äîa special file that discards anything written to it.

You can also use this trick to **clear a file‚Äôs content**:

```bash
cat /dev/null > /tmp/sysinfo.txt
```

This effectively wipes out the file by redirecting ‚Äúnothing‚Äù into it. The same can be also done using:-

```bash
> /tmp/sysinfo.txt
```

### Redirecting Errors

Sometimes, a command might throw an error. These error messages are sent to **standard error (stderr)**, not standard output. To redirect them, use `2>`:

```bash
freeeeee -m 2> /tmp/error.log
```

This command attempts to run an invalid command (`freeeeee`) and redirects the error to `/tmp/error.log`.

To redirect **both** output and error messages to the same file:

```bash
command &>> /tmp/logfile.txt
```

This is very useful in bash scripting when you want to store logs or review issues later.

### Input Redirection and Piping

Redirection isn't limited to output. You can also **pipe** the output of one command into another using the `|` (pipe) symbol.

For example, to count the number of files in a directory:

```bash
ls /etc | wc -l
```
The `wc -l /etc/passwd` command counts the number of lines in the given file.

To filter output:

```bash
free -m | grep Mem
ls /etc | grep host
tail -20 /var/log/messages | grep -i vagrant
```

To get the first 10 files in a directory: `ls -l /etc | head`
To get the last 10 files in a directory: `ls -l /etc | tail`

You can chain commands together in creative ways to process data more efficiently. This is a powerful skill in Linux scripting.

### Finding Files

To **search for a file**:

```bash
find /etc -name "host*"
```

This performs a real-time search in `/etc`. Be cautious with searching from `/` (the root) as it can slow your system down.

Alternatively, use the `locate` command for faster searches:

```bash
locate host
```

Note: If `locate` is not installed, then you need to install `yum install mlocate -y` and run `updatedb`.

The `locate` is not the real-time search therefore we have to use `updatedb`.

---

## 7. Understanding Users and Groups in Linux

In this section, we‚Äôll explore how Linux manages **users and groups**‚Äîthe fundamental elements used to control access to files, directories, and system resources.

### What Are Users and Groups?

In Linux, **everything is treated as a file**, and each file is owned by a **user** and associated with a **group**. This ownership structure helps enforce access control via permissions.

- Every user has a unique **User ID (UID)**.
- Groups have a **Group ID (GID)**.
- This information is stored in `/etc/passwd` (for user details) and `/etc/group` (for group memberships).
- Passwords are stored (in encrypted form) in `/etc/shadow`.

### Types of Users

Linux systems typically categorize users into three types:

| **Type**             | **Example**       | **User ID (UID)** | **Group ID (GID)** | **Home Dir**       | **Shell**                |
|----------------------|-------------------|--------------------|--------------------|---------------------|---------------------------|
| Root User            | `root`            | 0                  | 0                  | `/root`             | `/bin/bash`               |
| Regular User         | `vagrant`, `vks`| 1000 to 60000              | 1000 to 60000              | `/home/<username>`  | `/bin/bash` (or similar)  |
| System/Service User  | `sshd`, `ftp`, `apache`     | 1 to 999              | 1 to 999              | `/var/ftp`, etc.| `/sbin/nologin` or `/bin/false` |

1. **Root User**:- Has full administrative privileges.
2. **Regular Users**:- Used for day-to-day tasks by real people.
3. **System/Service Users**:- Often have no login shell (`/sbin/nologin` or `/bin/false`) and sometimes no home directory.

### Working with `/etc/passwd` and `/etc/group`

The `/etc/passwd` file contains information like:
- Username
- Link to encrypted password (indicated by `x`)
- UID (User ID)
- GID (Group ID)
- Comments
- Home directory
- Login shell

Example: `grep vagrant /etc/passwd`
```
vagrant:x:1000:1000:Vagrant User:/home/vagrant:/bin/bash
```

The `/etc/group` file lists group names and their members. For instance: `grep vagrant /etc/group`
```
vagrant:x:1000:
```

When creating a user, a primary group with the same name is usually created by default.

To get all the groups a user belongs to:
```bash
# id vagrant
uid=1000(vagrant) gid=1000(vagrant) groups=1000(vagrant)
```

### Creating Users and Groups

You can create users with the `useradd` command:
```bash
useradd ansible
useradd jenkins
useradd aws
```

Check their entries with:
```bash
tail -4 /etc/passwd
tail -4 /etc/group
```

Create a new group:
```bash
groupadd devops
```

### Adding Users to Groups

To add users to a secondary group:
```bash
usermod -aG devops ansible
```
Here `G` represents secondary group. For primary group we can use `g`.

Alternatively, directly edit `/etc/group`:
```bash
devops:x:1010:ansible,jenkins,aws
```

Check group membership:-
```bash
[root@centos ~]# id ansible
uid=1001(ansible) gid=1001(ansible) groups=1001(ansible),1004(devops)

[root@centos ~]# grep devops /etc/group
devops:x:1004:ansible
```

### Setting and Resetting Passwords

Root user can reset any users password by using `passwd username` command, also user can reset its own password by running just `passwd` command.

Set or reset a password:

```bash
passwd ansible
passwd aws
passwd jenkins
```

Only the **root user** can reset others‚Äô passwords. Root can also switch to any user without a password using: `su - user`

```bash
[root@centos ~]# su - ansible
[ansible@centos ~]$ whoami
ansible
```

Regular users will be prompted for a password when switching:
```bash
su - aws
```

Use `exit` to logout from the current user.

### Monitoring User Activity

Useful commands:
- `who`: See who is logged in.
- `whoami`: Shows current user.
- `last`: Shows login history.
- `lsof -u username`: Lists open files by a user (install `lsof` if needed). This command is often used to find open ports, logged in users, etc.

```bash
yum install lsof -y
lsof -u aws
```

### Deleting Users and Groups

Delete a user:
```bash
userdel aws
```
But it won't delete its home directory:- `ls /home`

Delete a user and their home directory:
```bash
userdel -r jenkins
userdel -r ansible
```

Delete a group:
```bash
groupdel devops
```

To remove remaining home directories manually:
```bash
rm -rf /home/aws
```

Finally, you can view your command history with:
```bash
history
```

---

## 8. File Permissions and Ownership in Linux

In this section, we‚Äôll explore how file permissions and ownership work in Linux, along with how to manage them using both symbolic and numeric methods.

### File Types and Ownership

Every file in Linux has an owner and an associated group. When you run `ls -l`, you‚Äôll see details like this:

```bash
-rw-r--r-- 1 root root 1234 Jan 1 12:00 anaconda-ks.cfg
```

- The first character (`-`) indicates the file type (`-` for file, `d` for directory, `l` for link).
- The next 9 characters represent permissions:  
  - `rw-` for the owner  
  - `r-x` for the group  
  - `r-x` for others

This means:
- **Owner (root)**: read & write (`rw-`)
- **Group (root)**: read & execute (`r-x`)
- **Others**: read & execute (`r-x`)

### Exploring Permissions with `ls -l`

Let's inspect files in the root user‚Äôs home directory:

```bash
ls -l ~
```

You‚Äôll see a mix of files, directories, and symbolic links. For example, for `anaconda-ks.cfg`, the file is owned by the `root` user and group. Its permissions are read and write for the owner, and none for group and others.

### Understanding Permission Bits

Permissions are divided into three sets:
- **User (owner)**: the creator or assigned user
- **Group**: members of the file‚Äôs group
- **Others**: everyone else

Each permission has a symbolic and numeric representation:
- **Read (r)** = 4  
- **Write (w)** = 2  
- **Execute (x)** = 1

So:
- `rwx` = 4+2+1 = **7**
- `rw-` = 4+2 = **6**
- `r--` = 4 = **4**

### Creating and Modifying Directories with Permissions

Let‚Äôs walk through an example.

1. **Create a new directory:**

```bash
mkdir /opt/devopsdir
```

2. **Create a group and users:**

```bash
groupadd devops
useradd ansible
useradd jenkins
useradd aws
useradd miles
```

3. **Add users (except `miles`) to the group:**
Edit the `/etc/group` file or use:

```bash
usermod -aG devops ansible
usermod -aG devops jenkins
usermod -aG devops aws
```

4. **Change ownership of the directory:**

```bash
chown ansible:devops /opt/devopsdir
```

If we want to change ownership of subdirectories also then we can use `-R`: `chown -R ansible:devops /opt/devopsdir`. Be careful while doing this because it will do recursive changes to the all subdirectories and we can't undo it.

```sh
# ls -ld /opt/devopsdir/
drwxr-xr-x. 2 ansible devops 6 Apr 14 15:52 /opt/devopsdir/

```

5. **Modify permissions:**
   - Add execute permission to the owner (`u`):
     ```bash
     chmod u+x /opt/devopsdir
     ```
   - Remove all permissions for others (`o`):
     ```bash
     chmod o-rx /opt/devopsdir
     ```
   - Add write permission to the group (`g`):
     ```bash
     chmod g+w /opt/devopsdir
     ```
   - Give execute permission to all users:
     ```bash
     chmod +x /opt/devopsdir
     ```

```bash
# ls -ld /opt/devopsdir/
drwxrwx---. 2 ansible devops 6 Apr 14 15:52 /opt/devopsdir/
```

Now:
- **User `ansible`** has full access.
- **Group `devops`** also has full access (can read, write, and execute).
- **Others** have no access at all.

### Testing Permissions

Switch to a user **not** in the `devops` group (like `miles`) and try:

```bash
su - miles
ls /opt/devopsdir       # Permission denied
cd /opt/devopsdir       # Permission denied
touch /opt/devopsdir/test.txt  # Permission denied
```

Switch to a user **in** the group (like `aws`) and try:

```bash
su - aws
cd /opt/devopsdir
touch awsfiles.txt      # File will be created successfully
```

### Using the Numeric Method (`chmod 770`)

Instead of using symbolic flags (`rwx`), you can assign permissions using numbers.

**Example:**
```bash
chmod 770 /opt/devopsdir
```

Breakdown:
- 7 (Owner): read (4) + write (2) + execute (1)
- 7 (Group): read (4) + write (2) + execute (1)
- 0 (Others): no permissions

**Another example:**
```bash
chmod 754 /opt/devopsdir
```

- 7: rwx (Owner)
- 5: r-x (Group)
- 4: r-- (Others)

This numeric method is quicker and often preferred in scripts or automated tasks.

Note:-
- `chown` command is to change ownership of the file.
- `chmod` is to change mode of a file.

---

## 9. Managing `sudo` Access in Linux Systems

In this section, we‚Äôll explore how the `sudo` command works in Linux and how to configure user access to execute privileged operations.

The `sudo` command allows a regular user to execute commands with root (administrator) privileges. It's commonly used to perform system-level tasks without logging in as the root user. For example, `sudo -i` opens a root shell, and `sudo yum install git` installs software packages with elevated permissions.

### Default Behavior of `sudo`

By default, only users listed in the `sudoers` file (usually members of the `sudo` or `wheel` group, depending on the distribution) can execute commands using `sudo`. If a user without proper permissions attempts to use `sudo`, they will receive an error message indicating they are not in the `sudoers` file.

### Granting `sudo` Access to a User

To allow a user to run commands with `sudo`, their privileges must be defined in the `/etc/sudoers` file or a configuration file under the `/etc/sudoers.d/` directory. It's important **not** to edit `/etc/sudoers` directly using regular text editors, as a syntax error can break access to administrative tasks.

Instead, always use the `visudo` command to safely edit the sudoers configuration:

```bash
sudo visudo
```

This command opens the `/etc/sudoers` file in a safe mode that performs syntax checking before saving changes. To grant a specific user full sudo access, add a line like the following:

```bash
username ALL=(ALL) ALL
```

If you want the user to be able to execute sudo commands **without being prompted for their password**, modify the entry as:

```bash
username ALL=(ALL) NOPASSWD: ALL
```

Example:-
```bash
[vagrant@centos ~]$ sudo -i

[root@centos ~]# passwd ansible
Changing password for user ansible.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.

[root@centos ~]# su - ansible
```
```bash
[ansible@centos ~]$ sudo useradd test12

We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

[sudo] password for ansible:
ansible is not in the sudoers file.  This incident will be reported.
```
```bash
[ansible@centos ~]$ sudo -i
[sudo] password for ansible:
ansible is not in the sudoers file.  This incident will be reported.

[ansible@centos ~]$ exit
```
Let us give the `ansible` user sudo access.
```bash
[root@centos ~]# ls -l /etc/sudoers
-r--r-----. 1 root root 4328 Jan 24  2024 /etc/sudoers

[root@centos ~]# visudo
```
In the line below from `root    ALL=(ALL)       ALL` add the line:- `ansible ALL=(ALL)       ALL`. Then save the file and exit using the command `:wq`. Now the `ansible` user can execute sudo commands.
```bash
[ansible@centos ~]$ sudo -i
[sudo] password for ansible:
```
To access the root user without password, we need to update the added line to the line `ansible ALL=(ALL) NOPASSWD: ALL` in the sudoers file.
```bash
[root@centos ~]# sudo visudo
[root@centos ~]# su - ansible
# login without password
[ansible@centos ~]$ sudo useradd test12
[ansible@centos ~]$ exit
```
In the `/etc/sudoers.d/` directory:-
```bash
[root@centos ~]# cd /etc/sudoers.d/
[root@centos sudoers.d]# ls
vagrant
[root@centos sudoers.d]# cat vagrant
%vagrant ALL=(ALL) NOPASSWD: ALL

[root@centos sudoers.d]# cp vagrant devops
[root@centos sudoers.d]# vim devops
```
In the file, add the following line:-
```bash
%devops ALL=(ALL) NOPASSWD: ALL
```

### Using the `/etc/sudoers.d/` Directory

A safer and more modular approach is to create a custom configuration file inside the `/etc/sudoers.d/` directory. This avoids modifying the main sudoers file and makes managing permissions easier.

For example, to grant sudo privileges to all users in a group named `devops`, create a file like this:

```bash
sudo visudo -f /etc/sudoers.d/devops
```

Then add the following line:

```bash
%devops ALL=(ALL) NOPASSWD: ALL
```

The `%` prefix indicates that this is a group, not a user.

### Handling Errors in `sudoers`

If a syntax error is introduced into the sudoers configuration, `visudo` will detect it upon saving and prompt you to correct it. If you attempt to edit the sudoers file without using `visudo` and introduce an error, you may lose sudo access entirely ‚Äî a serious issue if you don't have the root password.

### Summary

- `sudo` allows non-root users to execute commands with elevated privileges.
- Use `visudo` to safely edit the sudoers configuration.
- Add entries either directly in `/etc/sudoers` or create custom files in `/etc/sudoers.d/`.
- Avoid syntax errors ‚Äî always validate changes using `visudo`.
- Use the `NOPASSWD` directive for automation or non-interactive use cases.

---

## 10. Understanding Software & Package Management in Linux

Software management‚Äîbetter known in the Linux world as **package management**‚Äîis a fundamental concept every Linux user should grasp.

Think about all the times you've installed or uninstalled software on your computer or phone. In Linux, similar tasks are performed using packages, and the system used to manage them depends on your Linux distribution.

To explore this, we‚Äôll start from the basics: how to download and install a single package manually. Then, we‚Äôll gradually move on to using package management tools like `yum`, `dnf`, and `apt`.

### Two Popular Linux Distributions: CentOS vs Ubuntu

At the beginning of this journey, we created two virtual machines‚Äîone running **CentOS** and the other **Ubuntu**. The primary difference between these two is their **package management systems**:

- **CentOS** is **RPM-based** (uses `.rpm` files and tools like `yum` or `dnf`).
- **Ubuntu** is **Debian-based** (uses `.deb` files and tools like `apt`).

Let‚Äôs focus on the CentOS VM for now. If your VM isn‚Äôt running, bring it up and log in using `vagrant ssh`. Once inside, switch to the root user using:

```bash
sudo -i
```

Managing packages requires **root privileges**, so this step is essential.

### Identifying Your OS and Architecture

To confirm the type of OS and architecture, run `cat /etc/os-release`.

```bash
[root@centos ~]# cat /etc/os-release
NAME="CentOS Stream"
VERSION="9"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="9"
PLATFORM_ID="platform:el9"
PRETTY_NAME="CentOS Stream 9"
ANSI_COLOR="0;31"
LOGO="fedora-logo-icon"
CPE_NAME="cpe:/o:centos:centos:9"
HOME_URL="https://centos.org/"
BUG_REPORT_URL="https://issues.redhat.com/"
REDHAT_SUPPORT_PRODUCT="Red Hat Enterprise Linux 9"
REDHAT_SUPPORT_PRODUCT_VERSION="CentOS Stream"
```

You should see output like `ID="centos"` and `x86_64`, indicating a CentOS OS with a 64-bit architecture.

To see the list of available packages, run `rpm -qa` in Arch Linux. In Debian-based systems, use `dpkg -l` instead. You should see a list of installed packages. 

To see the architecture of the system (CPU), run `uname -m` or `arch`.

```bash
[root@centos ~]# arch
x86_64

[root@centos ~]# uname -m
x86_64
```

### Installing a Package Manually (RPM)

Let‚Äôs install a package named **telnet**. First, check if it‚Äôs already installed:

```bash
telnet
```

If you get an error like *command not found*, it means the telnet RPM isn‚Äôt installed.

Now, head to [rpmfind.net](https://rpmfind.net/linux/RPM/), search for **telnet**, and find a version compatible with **CentOS Stream 9** and **x86_64** architecture. Once you‚Äôve found the right package, copy the [download link](https://rpmfind.net/linux/centos-stream/9-stream/AppStream/x86_64/os/Packages/telnet-0.17-85.el9.x86_64.rpm).

Download the RPM using `curl` or `wget`. The file telnet.rpm will be saved in the current working directory

```bash
curl -o telnet.rpm <PASTE_DOWNLOAD_LINK_HERE>
```

Or, use `wget`:

```bash
wget <PASTE_DOWNLOAD_LINK_HERE>
```

Now install the RPM:

```bash
rpm -ivh telnet.rpm
```

**Flags**:
- **`-i`** ‚Üí **Install** the package  
- **`-v`** ‚Üí **Verbose** output (shows detailed progress)  
- **`-h`** ‚Üí **Hash marks** (shows progress as `#` while installing)

üëâ So `-ivh` = install with detailed, human-readable progress.

Verify the installation:

```bash
[root@centos ~]# telnet
telnet> quit

[root@centos ~]# rpm -qa | grep telnet
telnet-0.17-85.el9.x86_64
```

To uninstall:

```bash
rpm -e telnet
```

### Why Use Package Managers Like `yum` and `dnf`?

While RPM installation works, it doesn't automatically handle **dependencies**. For example, trying to install a web server like `httpd` using RPM can result in missing dependency errors.

```bash
[root@centos ~]# wget https://rpmfind.net/linux/centos-stream/9-stream/AppStream/x86_64/os/Packages/httpd-2.4.62-4.el9.x86_64.rpm

[root@centos ~]# rpm -ivh httpd-2.4.62-4.el9.x86_64.rpm
error: Failed dependencies:
        httpd-core = 0:2.4.62-4.el9 is needed by httpd-2.4.62-4.el9.x86_64
        system-logos-httpd is needed by httpd-2.4.62-4.el9.x86_64
```

That‚Äôs where **package managers** like `yum` and **`dnf`** (mostly used) come in. They automatically resolve and install all dependencies for you.

```bash
[root@centos ~]# cd /etc/yum.repos.d/
[root@centos yum.repos.d]# ls
centos-addons.repo  centos.repo
```

The `centos.repo` and`centos-addons.repo` files contain the list of repositories for CentOS Stream 9. See content of any of these files:
```bash
[root@centos yum.repos.d]# cat centos.repo
[baseos]
name=CentOS Stream $releasever - BaseOS
metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-$stream&arch=$basearch&protocol=https,http
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
gpgcheck=1
repo_gpgcheck=0
metadata_expire=6h
countme=1
enabled=1

[baseos-debuginfo]
name=CentOS Stream $releasever - BaseOS - Debug
metalink=https://mirrors.centos.org/metalink?repo=centos-baseos-debug-$stream&arch=$basearch&protocol=https,http
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial
gpgcheck=1
repo_gpgcheck=0
metadata_expire=6h
enabled=0

// More repos...
// enabled=1 enables the repo, enabled=0 disables the repo
```
When we search for a package, it checks for the avialable repositories and gives the list.

```bash
[root@centos yum.repos.d]# yum search httpd

========================= Name Exactly Matched: httpd ==========================
httpd.x86_64 : Apache HTTP Server
======================== Name & Summary Matched: httpd =========================
centos-logos-httpd.noarch : CentOS-related icons and pictures used by httpd
httpd-core.x86_64 : httpd minimal core
keycloak-httpd-client-install.noarch : Tools to configure Apache HTTPD as
                                     : Keycloak client
python3-keycloak-httpd-client-install.noarch : Tools to configure Apache HTTPD
                                             : as Keycloak client
============================= Name Matched: httpd ==============================
httpd-devel.x86_64 : Development interfaces for the Apache HTTP Server
httpd-filesystem.noarch : The basic directory layout for the Apache HTTP Server
httpd-manual.noarch : Documentation for the Apache HTTP Server
httpd-tools.x86_64 : Tools for use with the Apache HTTP Server
libmicrohttpd.i686 : Lightweight library for embedding a webserver in
                   : applications
libmicrohttpd.x86_64 : Lightweight library for embedding a webserver in
                     : applications
============================ Summary Matched: httpd ============================
mod_auth_mellon.x86_64 : A SAML 2.0 authentication module for the Apache Httpd
                       : Server
mod_dav_svn.x86_64 : Apache httpd module for Subversion server
mod_proxy_cluster.x86_64 : JBoss mod_proxy_cluster for Apache httpd
```

To install `httpd` using `yum` use `yum install httpd` or using `dnf` use `dnf install httpd`.

```bash
[root@centos yum.repos.d]# yum install httpd
CentOS Stream 9 - BaseOS                        8.5 kB/s | 6.3 kB     00:00
CentOS Stream 9 - BaseOS                        939 kB/s | 8.7 MB     00:09
CentOS Stream 9 - AppStream                      55 kB/s | 6.4 kB     00:00
CentOS Stream 9 - AppStream                     7.3 MB/s |  23 MB     00:03
CentOS Stream 9 - Extras packages                60 kB/s | 6.8 kB     00:00
Dependencies resolved.
================================================================================
 Package                  Architecture Version            Repository       Size
================================================================================
Installing:
 httpd                    x86_64       2.4.62-4.el9       appstream        47 k
Installing dependencies:
 apr                      x86_64       1.7.0-12.el9       appstream       123 k
 apr-util                 x86_64       1.6.1-23.el9       appstream        95 k
 apr-util-bdb             x86_64       1.6.1-23.el9       appstream        13 k
 centos-logos-httpd       noarch       90.8-2.el9         appstream       1.5 M
 httpd-core               x86_64       2.4.62-4.el9       appstream       1.5 M
 httpd-filesystem         noarch       2.4.62-4.el9       appstream        13 k
 httpd-tools              x86_64       2.4.62-4.el9       appstream        82 k
Installing weak dependencies:
 apr-util-openssl         x86_64       1.6.1-23.el9       appstream        15 k
 mod_http2                x86_64       2.0.26-4.el9       appstream       163 k
 mod_lua                  x86_64       2.4.62-4.el9       appstream        60 k

Transaction Summary
================================================================================
Install  11 Packages

Total download size: 3.6 M
Installed size: 8.6 M
Is this ok [y/N]:
```
```bash
[root@centos yum.repos.d]# dnf install httpd
Last metadata expiration check: 0:00:59 ago on Tue 15 Apr 2025 02:22:31 AM UTC.
Package httpd-2.4.62-4.el9.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
```

To remove it:

```bash
dnf remove httpd
```
Or,
```bash
yum remove httpd
```

Want to skip confirmation prompts?

```bash
dnf install -y httpd
```

To list available options:

```bash
dnf --help
```

To upgrade all packages:

```bash
dnf upgrade
```

### Managing Repositories

Repositories are where packages are stored. You can inspect them here:

```bash
cd /etc/yum.repos.d
ls
cat CentOS-Stream-AppStream.repo
```

To see all repositories:

```bash
[root@centos ~]# dnf repolist
repo id                       repo name
appstream                     CentOS Stream 9 - AppStream
baseos                        CentOS Stream 9 - BaseOS
extras-common                 CentOS Stream 9 - Extras packages
```

To clean the package cache (sometimes necessary when facing installation issues):

```bash
dnf clean all
```

### Adding External Repositories (e.g., Jenkins)

If a package isn‚Äôt found, like `jenkins`, it means none of the default repos include it. 

```bash
[root@centos ~]# yum install jenkins
Last metadata expiration check: 0:07:59 ago on Tue 15 Apr 2025 02:22:31 AM UTC.
No match for argument: jenkins
Error: Unable to find a match: jenkins

[root@centos ~]# yum search jenkins
Last metadata expiration check: 0:08:09 ago on Tue 15 Apr 2025 02:22:31 AM UTC.
No matches found.
```

Visit the official Jenkins website ([jenkins.io](https://www.jenkins.io)) and follow the installation instructions for your OS.

Example steps:

```bash
sudo wget -O /etc/yum.repos.d/jenkins.repo \
    https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
sudo yum upgrade
# Add required dependencies for the jenkins package
sudo dnf install fontconfig java-17-openjdk
sudo dnf install jenkins
sudo systemctl daemon-reload
```

Now Jenkins is installed via `dnf` using its official repo.

### Other Helpful Tools

- **EPEL Repository**: Provides access to additional packages.

  ```bash
  dnf install epel-release -y
  ```

- **Package History**: See what‚Äôs been installed, removed, or updated.

  ```bash
  dnf history
  ```

- **Group Installations**: Install groups like development tools.

  ```bash
  dnf group list
  dnf groupinstall "Development Tools"
  ```

---

**Wrapping up**: Installing software on Linux can be as simple or as advanced as you want it to be. Whether you‚Äôre downloading individual RPMs or using powerful tools like `dnf`, the key is understanding your system architecture, your distribution‚Äôs package format, and how to interact with repositories.

How to install single package in RedHat & Debian OS?
- `rpm -i packagename` in RedHat OS 
- `dpkg -i packagename` in Debian OS

Where are yum repos and apt repos files located?
- `/etc/yum.repos.d` in yum and `/etc/apt/sources.list` & `/etc/apt/sources.list.d` in apt.

Before installing package in ubuntu with apt command, we should run apt update to refresh apt repository index:- `sudo apt update`
---

## 11. Managing Services in Linux with `systemctl`

In this section, we'll explore how to manage services on a Linux system using the `systemctl` command. Whether you're checking the status of built-in services or managing your own, understanding how services work is essential.

Let‚Äôs take the example of the `httpd` package, which provides the Apache web server. You can install it using:

```bash
yum install httpd -y
```

Once installed, it registers a service named `httpd` that can be controlled using `systemctl`. To check its current state, run: `systemctl status httpd`.

```bash
[root@centos ~]# systemctl status httpd
‚óã httpd.service - The Apache HTTP Server
     Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled; preset: disabled)
     Active: inactive (dead)
       Docs: man:httpd.service(8)
```

This will show whether the service is active or inactive. If it's inactive, you can start it with:

```bash
systemctl start httpd
```

After starting, running the status command again should show the service as active. Behind the scenes, starting a service means initiating one or more processes. You can also stop, restart, or reload a service using:

```bash
systemctl stop httpd
systemctl restart httpd
systemctl reload httpd
```

- **`restart`** is used when you‚Äôve made config changes and want a clean restart.
- **`reload`** attempts to apply changes without stopping the service.

### Starting Services at Boot

By default, starting a service manually only runs it for the current session. If you reboot the system, it won‚Äôt start automatically. 

```bash
sudo reboot
vagrant ssh
sudo -i
systemctl status httpd
```

To make a service start at boot, use:

```bash
systemctl enable httpd
```
In the current session, it won't start automatically so you can call `systemctl start httpd` to start it.

```bash
systemctl enable httpd
systemctl start httpd
```
Or, you can use:-

```bash
systemctl enable --now httpd
```

This command:
- Enables the service to **start at boot**
- Immediately **starts** the service in the current session

Likewise, you can also **disable and stop** a service with:

```bash
systemctl disable --now httpd
```

To confirm its status or boot-time behavior:

```bash
systemctl is-active httpd     # Check if the service is running
systemctl is-enabled httpd    # Check if the service is enabled at boot
```

If you're using tools like Vagrant, a reboot can be done with:

```bash
vagrant reload
# or
reboot
```

After rebooting, log in and verify whether the service is running. If it‚Äôs inactive, that means it wasn‚Äôt enabled for boot.

We are using `vagrant ssh` to log into the VM, and it depends on `sshd` serice:- `systemctl status sshd`

### How `systemctl` Works Internally

When you install a package like `httpd`, a service definition (`httpd.service`) file is automatically created under `/etc/systemd/system/multi-user.target.wants/`

```bash
[root@centos ~]# cat /etc/systemd/system/multi-user.target.wants/httpd.service
# See httpd.service(8) for more information on using the httpd service.

# Modifying this file in-place is not recommended, because changes
# will be overwritten during package upgrades.  To customize the
# behaviour, run "systemctl edit httpd" to create an override unit.

# For example, to pass additional options (such as -D definitions) to
# the httpd binary at startup, create an override unit (as is done by
# systemctl edit) and enter the following:

#       [Service]
#       Environment=OPTIONS=-DMY_DEFINE

[Unit]
Description=The Apache HTTP Server
Wants=httpd-init.service
After=network.target remote-fs.target nss-lookup.target httpd-init.service
Documentation=man:httpd.service(8)

[Service]
Type=notify
Environment=LANG=C

ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND
ExecReload=/usr/sbin/httpd $OPTIONS -k graceful
# Send SIGWINCH for graceful stop
KillSignal=SIGWINCH
KillMode=mixed
PrivateTmp=true
OOMPolicy=continue

[Install]
WantedBy=multi-user.target
```

This file tells `systemctl` how to start or stop the service using the defined commands. For services installed from tarballs or custom binaries, you may need to create your own `.service` files to enable management via `systemctl`.

---

## 12. Understanding and Managing Linux Processes

In this section, we‚Äôll dive into how processes work in a Linux system and how you can monitor and manage them effectively using basic commands.

### Viewing Running Processes with `top`

Linux runs numerous processes at any given time ‚Äî some active, some sleeping. The `top` command is one of the most useful tools to monitor them in real-time. It functions similarly to Task Manager in Windows.

```bash
[root@centos ~]# top
top - 03:10:16 up 17 min,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   1771.5 total,   1393.6 free,    320.9 used,    207.7 buff/cache
MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   1450.6 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    661 root      20   0  161076   8676   5120 S   0.3   0.5   0:00.41 rsyslogd
   4284 root      20   0   10552   4224   3456 R   0.3   0.2   0:00.03 top
      1 root      20   0  110028  18480  10896 S   0.0   1.0   0:02.21 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.01 kthreadd
      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-rcu_g
      5 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-sync_
      6 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-slub_
      7 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-netns
      9 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/0:0H-events_highpri
     10 root      20   0       0      0      0 I   0.0   0.0   0:00.00 kworker/u8:0-events_unbound
```

When you run `top`, you'll see:

- **Uptime** of the system
- **Number of users** logged in
- **Load average** (CPU wait time) over the last 1, 5, and 15 minutes
- **Task summary**: running, sleeping, stopped, or zombie processes
- **CPU and RAM usage**
- **Process list**, dynamically sorted by CPU usage

Each process includes details like PID (Process ID), user, status (e.g., sleeping "S"), CPU/RAM usage, and command name. Press `q` to quit `top`.

> üí° For memory info in a simpler format, use `free -m`.

### Static Process Snapshot with `ps`

The `ps` command gives a snapshot of current processes:

- `ps aux`: Lists all processes with details like PID, CPU/RAM usage, user, and process command.
- `ps -ef`: Also lists all processes but focuses on hierarchy using PPID (Parent Process ID), helpful for tracing which process started others.

```bash
[root@centos ~]# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.1  1.0 110028 18480 ?        Ss   02:53   0:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2  0.0  0.0      0     0 ?        S    02:53   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        S    02:53   0:00 [pool_workqueue_]
root           4  0.0  0.0      0     0 ?        I<   02:53   0:00 [kworker/R-rcu_g]
root           9  0.0  0.0      0     0 ?        I<   02:53   0:00 [kworker/0:0H-events_highpri]
root          10  0.0  0.0      0     0 ?        I    02:53   0:00 [kworker/u8:0-events_unbound]
root          11  0.0  0.0      0     0 ?        I<   02:53   0:00 [kworker/R-mm_pe]
root         391  0.0  0.0      0     0 ?        S    02:53   0:00 [xfsaild/sda2]
root         462  0.0  0.5  23888  9344 ?        Ss   02:53   0:00 /usr/lib/systemd/systemd-journald
root         470  0.0  0.0      0     0 ?        I    02:53   0:00 [kworker/1:4-mm_percpu_wq]
root         476  0.0  0.7  37236 12844 ?        Ss   02:53   0:00 /usr/lib/systemd/systemd-udevd
root         508  0.0  0.0      0     0 ?        I<   02:53   0:00 [kworker/R-xfs-b]
root         515  0.0  0.0      0     0 ?        S    02:53   0:00 [xfsaild/sda1]
root         525  0.0  0.1  96176  2884 ?        S<sl 02:53   0:00 /sbin/auditd
root         527  0.0  0.1   7688  3328 ?        S<   02:53   0:00 /usr/sbin/sedispatch
dbus         553  0.0  0.2  10772  4992 ?        Ss   02:53   0:00 /usr/bin/dbus-broker-launch --scope system --audit
dbus         554  0.0  0.1   5280  3168 ?        S    02:53   0:00 dbus-broker --log 4 --controller 9 --machine-id f5ba50d49912402a977c9149838a614f --max-bytes 536870912 --max-fds 4096 --max-matches 131072 --audit
root         555  0.0  1.3 258980 23756 ?        Ssl  02:53   0:00 /usr/sbin/NetworkManager --no-daemon
root         558  0.0  0.2  82628  3968 ?        Ssl  02:53   0:00 /usr/sbin/irqbalance
libstor+     559  0.0  0.0   2704  1792 ?        Ss   02:53   0:00 /usr/bin/lsmd -d
root         560  0.0  0.1   3336  2048 ?        Ss   02:53   0:00 /usr/sbin/mcelog --daemon --foreground
root         562  0.0  0.8  31140 14960 ?        Ss   02:53   0:00 /usr/lib/systemd/systemd-logind
chrony       570  0.0  0.2  84948  4660 ?        S    02:53   0:00 /usr/sbin/chronyd -F 2
root         635  0.0  0.5  18760  9984 ?        Ss   02:53   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root         641  0.0  0.2  12472  4992 ?        Ss   02:53   0:00 /usr/sbin/atd -f
root         644  0.0  0.1   8568  3584 ?        Ss   02:53   0:00 /usr/sbin/crond -n
root         648  0.0  0.1   3044  1920 tty1     Ss+  02:53   0:00 /sbin/agetty -o -p -- \u --noclear - linux
root         661  0.0  0.4 161076  8676 ?        Ssl  02:53   0:00 /usr/sbin/rsyslogd -n
root        4049  0.0  0.6  20268 11776 ?        Ss   02:53   0:00 sshd: vagrant [priv]
vagrant     4053  0.0  0.7  23792 13948 ?        Ss   02:53   0:00 /usr/lib/systemd/systemd --user
vagrant     4055  0.0  0.4  28588  8632 ?        S    02:53   0:00 (sd-pam)
vagrant     4063  0.0  0.4  20556  7432 ?        S    02:53   0:00 sshd: vagrant@pts/0
vagrant     4064  0.0  0.2   8688  5376 pts/0    Ss   02:53   0:00 -bash
root        4174  0.0  0.4  21044  8960 pts/0    S    02:53   0:00 sudo -i
root        4176  0.0  0.3   8840  5504 pts/0    S    02:53   0:00 -bash
root        4249  0.1  0.0      0     0 ?        I    02:59   0:01 [kworker/1:0-mm_percpu_wq]
root        4275  0.0  0.0   5592  1536 ?        Ss   03:01   0:00 /usr/sbin/anacron -s
root        4282  0.0  0.0      0     0 ?        I    03:08   0:00 [kworker/0:1-cgroup_destroy]
root        4290  0.0  0.1   9968  3456 pts/0    R+   03:14   0:00 ps aux
```
```bash
[root@centos ~]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 02:53 ?        00:00:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2       0  0 02:53 ?        00:00:00 [kthreadd]
root           3       2  0 02:53 ?        00:00:00 [pool_workqueue_]
root           4       2  0 02:53 ?        00:00:00 [kworker/R-rcu_g]
root           5       2  0 02:53 ?        00:00:00 [kworker/R-sync_]
root           6       2  0 02:53 ?        00:00:00 [kworker/R-slub_]
root           7       2  0 02:53 ?        00:00:00 [kworker/R-netns]
root           9       2  0 02:53 ?        00:00:00 [kworker/0:0H-events_highpri]
root          10       2  0 02:53 ?        00:00:00 [kworker/u8:0-events_unbound]
root          11       2  0 02:53 ?        00:00:00 [kworker/R-mm_pe]
root          12       2  0 02:53 ?        00:00:00 [kworker/u8:1-netns]
root          13       2  0 02:53 ?        00:00:00 [rcu_tasks_kthre]
root          14       2  0 02:53 ?        00:00:00 [rcu_tasks_rude_]
root          15       2  0 02:53 ?        00:00:00 [rcu_tasks_trace]
root          16       2  0 02:53 ?        00:00:00 [ksoftirqd/0]
root          17       2  0 02:53 ?        00:00:00 [pr/ttyS0]
root          18       2  0 02:53 ?        00:00:00 [rcu_preempt]
root          19       2  0 02:53 ?        00:00:00 [rcu_exp_par_gp_]
root          20       2  0 02:53 ?        00:00:00 [rcu_exp_gp_kthr]
root          21       2  0 02:53 ?        00:00:00 [migration/0]
root          22       2  0 02:53 ?        00:00:00 [idle_inject/0]
root          24       2  0 02:53 ?        00:00:00 [cpuhp/0]
root          25       2  0 02:53 ?        00:00:00 [cpuhp/1]
root          26       2  0 02:53 ?        00:00:00 [idle_inject/1]
root          27       2  0 02:53 ?        00:00:00 [migration/1]
root          28       2  0 02:53 ?        00:00:00 [ksoftirqd/1]
root          30       2  0 02:53 ?        00:00:00 [kworker/1:0H-events_highpri]
root          31       2  0 02:53 ?        00:00:01 [kworker/u9:0-events_unbound]
root          34       2  0 02:53 ?        00:00:00 [kworker/u9:1-events_unbound]
root          35       2  0 02:53 ?        00:00:00 [kworker/u10:1-events_unbound]
root          36       2  0 02:53 ?        00:00:00 [kdevtmpfs]
root          37       2  0 02:53 ?        00:00:00 [kworker/R-inet_]
root          38       2  0 02:53 ?        00:00:00 [kauditd]
root          39       2  0 02:53 ?        00:00:00 [khungtaskd]
root          40       2  0 02:53 ?        00:00:00 [oom_reaper]
```

You‚Äôll notice:
- **PID 1** is usually `systemd` (or `init` in some systems), the first process started by the kernel.
- Kernel threads appear in **square brackets**.
- Services like `httpd` or `sshd` will often have a parent-child hierarchy.

### Killing Processes

If you need to stop a process:
1. Identify the process with:
   ```bash
   ps -ef | grep httpd | grep -v grep
   ```
   or,
   ```bash
   pgrep httpd
   ```

   Example:-
   ```bash
    [root@centos ~]# ps -ef | grep httpd | grep -v grep
    root        4328       1  1 03:24 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
    apache      4329    4328  0 03:24 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
    apache      4330    4328  0 03:24 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
    apache      4331    4328  0 03:24 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND
    apache      4332    4328  0 03:24 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND

    [root@centos ~]# pgrep httpd
    4328
    4329
    4330
    4331
    4332
   ```
2. Kill the parent process:
   ```bash
   kill <PID>
   ```
   This gracefully requests the process to terminate, closing its children first.

3. If the process is unresponsive:
   ```bash
   kill -9 <PID>
   ```
   This forcefully terminates it. Note: Child processes may become **orphans**.

To kill all child processes at once:
```bash
ps -ef | grep httpd | grep -v grep | awk '{print $2}' | xargs kill -9
```
Or,
```bash
pgrep httpd | xargs kill -9
```

### Orphan & Zombie Processes

- **Orphan Processes**: Child processes whose parent is terminated. They're usually adopted by `systemd` (PID 1). These can be cleaned up manually to free resources.
- **Zombie Processes**: Processes that have completed but remain in the process table. Their status appears as `Z` in `ps aux`. These don‚Äôt consume resources but might cause issues ‚Äî a reboot typically clears them.

### Summary

- `kill -9 PID` command is to stop process forcefully and `kill PID`  is to stop process gracefully, child processes also will be stopped if parent process is stopped gracefully.
- Difference between Zombie & Orphan Process:- A child process that remains runing even after its parent process is terminated or completed without waiting for the child process execution is called a Orphan process. Zombie process that has completed its task but still, it shows an entry in the process table is called Zombie process.

With these tools ‚Äî `top`, `ps`, `kill`, `awk`, and `xargs`‚Äîyou‚Äôre well-equipped to monitor and manage Linux processes efficiently. In the next section, we‚Äôll explore more advanced process control and automation.

---

## 13. üì¶ Archiving and Compressing Files in Linux

Archiving files and directories is a common and essential task in Linux, especially when taking backups, transferring files, or cleaning up logs. In this section, we‚Äôll explore two widely-used tools for archiving and compressing: `tar` and `zip`.

### üîπ Archiving with `tar`

The `tar` command is a legacy yet powerful utility still widely used in Linux systems. Let's walk through a practical example of archiving the Jenkins logs located in `/var/log/jenkins`.

To create a compressed tarball of the `jenkins` directory:

```bash
tar -czvf jenkins_$(date +%Y%m%d).tar.gz /var/log/jenkins
```

- `c` ‚Äì Create a new archive  
- `z` ‚Äì Compress with gzip  
- `v` ‚Äì Verbose output (shows progress)  
- `f` ‚Äì File name for the archive  

After creation, you can verify the tarball:

```bash
ls -ltr
file jenkins_*.tar.gz
```

Even without an extension, the `file` command helps identify the archive type.

To extract the tarball:

```bash
tar -xzvf jenkins_20250415.tar.gz
```

To extract it to a specific directory, such as `/opt`:

```bash
tar -xzvf jenkins_20250415.tar.gz -C /opt
```

Other handy `tar` options:

- `-d` ‚Äì Compare archive contents with file system  
- `--update` ‚Äì Add or update files in an archive  
- `-j` ‚Äì Use `bzip2` for compression  
- `-J` ‚Äì Use `xz` for compression  
- `-a` ‚Äì Automatically detect compression based on file extension  

### üîπ Archiving with `zip`

If you're looking for something simpler, `zip` and `unzip` are great alternatives‚Äîespecially when working with systems where these formats are preferred.

First, install the tools if not already available:

```bash
yum install zip unzip -y
```

To zip the `jenkins` directory:

```bash
zip -r jenkins_$(date +%Y%m%d).zip /var/log/jenkins
```

Move it to another location (e.g., `/opt`) and unzip:

```bash
mv jenkins_20250415.zip /opt/
cd /opt
unzip jenkins_20250415.zip
```

Make sure the target directory doesn‚Äôt already exist, or `unzip` will overwrite it.

### üîç Summary

- Use `tar` for traditional and feature-rich archiving, especially when working with `.tar.gz` or `.tar.bz2`.
- Use `zip` for simplicity and compatibility, especially across different operating systems.
- Always consider adding timestamps to your archive names for easier versioning and tracking.

Practice both tools‚Äîthey‚Äôre incredibly useful for system administration, backups, and automation!

---

## 14. üêß Getting Started with Ubuntu ‚Äì Key Differences from CentOS

Welcome! In this section, we‚Äôll explore the **Ubuntu operating system** and highlight how it compares to CentOS. While most Linux commands work similarly across both distributions, there are a few important differences worth noting. Let's dive into setting up and working with Ubuntu using **Vagrant**, and explore its unique tools and behavior.

### üîß Spinning Up Ubuntu with Vagrant

We‚Äôre using Vagrant to manage our virtual machines. If you've followed our VM setup lecture, you should already have an Ubuntu VM configuration.

1. Navigate to your Ubuntu Vagrant directory:
   ```bash
   cd vagrant-vms/ubuntu
   ```

2. Check the VM status:
   ```bash
   vagrant global-status
   ```

3. Start the Ubuntu VM:
   ```bash
   vagrant up
   ```

4. Log in:
   ```bash
   vagrant ssh
   ```

Clear the screen and verify the OS:

```bash
cat /etc/os-release
```

You'll see you're working on **Ubuntu 22.x**.

Switch to the root user and check your current user and directory:

```bash
sudo -i
whoami
pwd
```

### üë• Creating Users ‚Äì `useradd` vs `adduser`

On CentOS, `useradd` creates a user **along with** a home directory and mail spool. In Ubuntu, however:

```bash
useradd devops
```

- Creates the user, **but not** the home directory or mail spool.
- Logging into the new user will drop you into `/` instead of `/home/devops`.

To delete this incomplete user:

```bash
userdel -r devops
```

You‚Äôll see a warning about the missing home directory and mail spool.

‚úÖ **Better approach in Ubuntu**: Use `adduser`, which is more user-friendly.

```bash
adduser devops
```

This command:
- Creates the user and group
- Sets a password
- Copies default files from `/etc/skel` to the user‚Äôs home
- Prompts for optional user info

### üìù Default Editor for `visudo`

When running:

```bash
visudo
```

Ubuntu opens the file in **nano** by default. If you prefer **Vim**:

1. Temporarily set Vim as your default editor:

   ```bash
   export EDITOR=vim
   visudo
   ```

2. To quit Vim: `:q`

> Note: This change only affects the current shell. We'll cover how to make it permanent in the Bash scripting section.

### üì¶ Installing Packages ‚Äì `dpkg` and `apt`

Ubuntu uses `.deb` packages, unlike `.rpm` on CentOS. You can install software two ways:

#### üõ† Manual Install (using `dpkg`):

1. Download a package (example: `tree`):

   ```bash
   wget <tree-package-url>
   dpkg -i tree.deb
   ```

2. Verify installation:

   ```bash
   tree
   ```

3. List installed packages:

   ```bash
   dpkg -l
   ```

4. Search for a package:

   ```bash
   dpkg -l | grep tree
   ```

5. Remove a package:

   ```bash
   dpkg -r tree
   ```

#### üöÄ Install via `apt`

Ubuntu‚Äôs default package manager is `apt`, which is more robust and convenient.

1. Check repositories:
   ```bash
   cat /etc/apt/sources.list
   ```

2. Update package list:
   ```bash
   apt update
   ```

3. Search for a package:
   ```bash
   apt search tree
   ```

4. Install a package:
   ```bash
   apt install tree
   ```

5. Install a service (e.g. Apache):
   ```bash
   apt install apache2
   ```

- Installs with all dependencies
- Starts and enables the service automatically

6. Verify service status:
   ```bash
   systemctl status apache2
   ```

7. Remove a package (keeping config):
   ```bash
   apt remove apache2
   ```

8. Remove a package **completely** (including config/data):
   ```bash
   apt purge apache2
   ```

### üî• Bonus: Ubuntu Firewall (UFW)

Ubuntu uses **UFW (Uncomplicated Firewall)** to manage firewall rules. When installing services like Apache, UFW rules are updated automatically.

### üß† Summary

Here are the key differences to remember when working with Ubuntu:

| Feature             | CentOS             | Ubuntu                |
|---------------------|--------------------|------------------------|
| Package Manager     | `yum`              | `apt`                 |
| User Creation       | `useradd`          | `adduser` (preferred) |
| Text Editor for visudo | `vim` by default | `nano` by default     |
| Firewall Tool       | `firewalld`        | `ufw`                 |

Ubuntu offers an extensive range of available software, easier package management, and quick service setup ‚Äî all of which make it beginner-friendly.

üß™ **Practice these commands to build confidence working on Ubuntu systems.** You‚Äôll encounter both Ubuntu and CentOS in real-world environments, so it's great to be fluent with both!

---
